{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"IronCore Documentation","text":"<p>This page contains the documentation of the ironcore project which is part  of the ironcore-dev organization.</p>"},{"location":"api-reference/common/","title":"Common","text":"<p>Packages:</p> <ul> <li> common.ironcore.dev/v1alpha1 </li> </ul>"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1","title":"common.ironcore.dev/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p>"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1.ConfigMapKeySelector","title":"ConfigMapKeySelector","text":"<p>ConfigMapKeySelector is a reference to a specific \u2018key\u2019 within a ConfigMap resource. In some instances, <code>key</code> is a required field.</p> Field Description <code>name</code>  string  <p>Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</p> <code>key</code>  string  (Optional) <p>The key of the entry in the ConfigMap resource\u2019s <code>data</code> field to be used. Some instances of this field may be defaulted, in others it may be required.</p>"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1.IP","title":"IP","text":"<p> (Appears on:IPRange) </p> <p>IP is an IP address.</p> Field Description <code>-</code>  net/netip.Addr"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1.IPPrefix","title":"IPPrefix","text":"<p>IPPrefix represents a network prefix.</p> Field Description <code>-</code>  net/netip.Prefix"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1.IPRange","title":"IPRange","text":"<p>IPRange is an IP range.</p> Field Description <code>from</code>  IP  <code>to</code>  IP"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1.LocalUIDReference","title":"LocalUIDReference","text":"<p>LocalUIDReference is a reference to another entity including its UID</p> Field Description <code>name</code>  string  <p>Name is the name of the referenced entity.</p> <code>uid</code>  k8s.io/apimachinery/pkg/types.UID  <p>UID is the UID of the referenced entity.</p>"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1.SecretKeySelector","title":"SecretKeySelector","text":"<p>SecretKeySelector is a reference to a specific \u2018key\u2019 within a Secret resource. In some instances, <code>key</code> is a required field.</p> Field Description <code>name</code>  string  <p>Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names</p> <code>key</code>  string  (Optional) <p>The key of the entry in the Secret resource\u2019s <code>data</code> field to be used. Some instances of this field may be defaulted, in others it may be required.</p>"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1.Taint","title":"Taint","text":"<p>The resource pool this Taint is attached to has the \u201ceffect\u201d on any resource that does not tolerate the Taint.</p> Field Description <code>key</code>  string  <p>The taint key to be applied to a resource pool.</p> <code>value</code>  string  <p>The taint value corresponding to the taint key.</p> <code>effect</code>  TaintEffect  <p>The effect of the taint on resources that do not tolerate the taint. Valid effects are NoSchedule, PreferNoSchedule and NoExecute.</p>"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1.TaintEffect","title":"TaintEffect (<code>string</code> alias)","text":"<p> (Appears on:Taint, Toleration) </p> Value Description <p>\"NoSchedule\"</p> <p>TaintEffectNoSchedule is not allowing new resources to be scheduled onto the resource pool unless they tolerate the taint, but allow all already-running resources to continue running. This is enforced by the scheduler.</p>"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1.Toleration","title":"Toleration","text":"<p>Toleration is attached to tolerate any taint that matches the triple {key,value,effect} using the matching operator.</p> Field Description <code>key</code>  string  <p>Key is the taint key that the toleration applies to. Empty means match all taint keys. If the key is empty, operator must be Exists; this combination means to match all values and all keys.</p> <code>operator</code>  TolerationOperator  <p>Operator represents a key\u2019s relationship to the value. Valid operators are Exists and Equal. Defaults to Equal. Exists is equivalent to wildcard for value, so that a resource can tolerate all taints of a particular category.</p> <code>value</code>  string  <p>Value is the taint value the toleration matches to. If the operator is Exists, the value should be empty, otherwise just a regular string.</p> <code>effect</code>  TaintEffect  <p>Effect indicates the taint effect to match. Empty means match all taint effects. When specified, allowed values are NoSchedule.</p>"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1.TolerationOperator","title":"TolerationOperator (<code>string</code> alias)","text":"<p> (Appears on:Toleration) </p> <p>TolerationOperator is the set of operators that can be used in toleration.</p> Value Description <p>\"Equal\"</p> <p>\"Exists\"</p>"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1.TopologyLabel","title":"TopologyLabel (<code>string</code> alias)","text":"<p>TopologyLabel represents a topology label that can be configured on machinepoollet, volumepoollet, and bucketpoollet, which set them on MachinePool, VolumePool, and BucketPool resources. These labels are managed exclusively by the respective poollet controllers (machinepoollet, volumepoollet, bucketpoollet). Any manual changes to these labels will be overwritten by the poollet controllers. The intent is similar to Kubernetes\u2019 topology labels.</p> Value Description <p>\"topology.ironcore.dev/region\"</p> <p>TopologyLabelRegion is a label applied to MachinePool, VolumePool, and BucketPool resources. Machines, Volumes, and Buckets can use this label in their pool selectors. The intent is similar to Kubernetes\u2019 topology labels (e.g., <code>topology.kubernetes.io/region</code>).</p> <p>\"topology.ironcore.dev/zone\"</p> <p>TopologyLabelZone is a label applied to MachinePool, VolumePool, and BucketPool resources. Machines, Volumes, and Buckets can use this label in their pool selectors. The intent is similar to Kubernetes\u2019 topology labels (e.g., <code>topology.kubernetes.io/zone</code>).</p>"},{"location":"api-reference/common/#common.ironcore.dev/v1alpha1.UIDReference","title":"UIDReference","text":"<p>UIDReference is a reference to another entity in a potentially different namespace including its UID.</p> Field Description <code>namespace</code>  string  <p>Namespace is the namespace of the referenced entity. If empty, the same namespace as the referring resource is implied.</p> <code>name</code>  string  <p>Name is the name of the referenced entity.</p> <code>uid</code>  k8s.io/apimachinery/pkg/types.UID  <p>UID is the UID of the referenced entity.</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"api-reference/compute/","title":"Compute","text":"<p>Packages:</p> <ul> <li> compute.ironcore.dev/v1alpha1 </li> </ul>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1","title":"compute.ironcore.dev/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p> <ul><li> Machine </li><li> MachineClass </li><li> MachinePool </li></ul>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.Machine","title":"Machine","text":"<p>Machine is the Schema for the machines API</p> Field Description <code>apiVersion</code> string <code> compute.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>Machine</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  MachineSpec  <code>machineClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>MachineClassRef is a reference to the machine class/flavor of the machine.</p> <code>machinePoolSelector</code>  map[string]string  <p>MachinePoolSelector selects a suitable MachinePoolRef by the given labels.</p> <code>machinePoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>MachinePoolRef defines machine pool to run the machine in. If empty, a scheduler will figure out an appropriate pool to run the machine in.</p> <code>power</code>  Power  <p>Power is the desired machine power state. Defaults to PowerOn.</p> <code>image</code>  string  (Optional) <p>Deprecated: Use LocalDisk to provide a bootable disk Image is the optional URL providing the operating system image of the machine.</p> <code>imagePullSecret</code>  Kubernetes core/v1.LocalObjectReference  <p>ImagePullSecretRef is an optional secret for pulling the image of a machine.</p> <code>networkInterfaces</code>  []NetworkInterface  (Optional) <p>NetworkInterfaces define a list of network interfaces present on the machine</p> <code>volumes</code>  []Volume  (Optional) <p>Volumes are volumes attached to this machine.</p> <code>ignitionRef</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.SecretKeySelector  <p>IgnitionRef is a reference to a secret containing the ignition YAML for the machine to boot up. If key is empty, DefaultIgnitionKey will be used as fallback.</p> <code>efiVars</code>  []EFIVar  (Optional) <p>EFIVars are variables to pass to EFI while booting up.</p> <code>tolerations</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Machine has. Only MachinePools whose taints covered by Tolerations will be considered to run the Machine.</p> <code>status</code>  MachineStatus"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachineClass","title":"MachineClass","text":"<p>MachineClass is the Schema for the machineclasses API</p> Field Description <code>apiVersion</code> string <code> compute.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>MachineClass</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>capabilities</code>  github.com/ironcore-dev/ironcore/api/core/v1alpha1.ResourceList"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachinePool","title":"MachinePool","text":"<p>MachinePool is the Schema for the machinepools API</p> Field Description <code>apiVersion</code> string <code> compute.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>MachinePool</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  MachinePoolSpec  <code>providerID</code>  string  <p>ProviderID identifies the MachinePool on provider side.</p> <code>taints</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Taint  <p>Taints of the MachinePool. Only Machines who tolerate all the taints will land in the MachinePool.</p> <code>status</code>  MachinePoolStatus"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.DaemonEndpoint","title":"DaemonEndpoint","text":"<p> (Appears on:MachinePoolDaemonEndpoints) </p> <p>DaemonEndpoint contains information about a single Daemon endpoint.</p> Field Description <code>port</code>  int32  <p>Port number of the given endpoint.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.EFIVar","title":"EFIVar","text":"<p> (Appears on:MachineSpec) </p> <p>EFIVar is a variable to pass to EFI while booting up.</p> Field Description <code>name</code>  string  <p>Name is the name of the EFIVar.</p> <code>uuid</code>  string  <p>UUID is the uuid of the EFIVar.</p> <code>value</code>  string  <p>Value is the value of the EFIVar.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.EmptyDiskVolumeSource","title":"EmptyDiskVolumeSource","text":"<p> (Appears on:VolumeSource) </p> <p>EmptyDiskVolumeSource is a volume that\u2019s offered by the machine pool provider. Usually ephemeral (i.e. deleted when the surrounding entity is deleted), with varying performance characteristics. Potentially not recoverable.</p> Field Description <code>sizeLimit</code>  k8s.io/apimachinery/pkg/api/resource.Quantity  <p>SizeLimit is the total amount of local storage required for this EmptyDisk volume. The default is nil which means that the limit is undefined.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.EphemeralNetworkInterfaceSource","title":"EphemeralNetworkInterfaceSource","text":"<p> (Appears on:NetworkInterfaceSource) </p> <p>EphemeralNetworkInterfaceSource is a definition for an ephemeral (i.e. coupled to the lifetime of the surrounding object) networking.NetworkInterface.</p> Field Description <code>networkInterfaceTemplate</code>  github.com/ironcore-dev/ironcore/api/networking/v1alpha1.NetworkInterfaceTemplateSpec  <p>NetworkInterfaceTemplate is the template definition of the networking.NetworkInterface.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.EphemeralVolumeSource","title":"EphemeralVolumeSource","text":"<p> (Appears on:VolumeSource) </p> <p>EphemeralVolumeSource is a definition for an ephemeral (i.e. coupled to the lifetime of the surrounding object) storage.Volume.</p> Field Description <code>volumeTemplate</code>  github.com/ironcore-dev/ironcore/api/storage/v1alpha1.VolumeTemplateSpec  <p>VolumeTemplate is the template definition of the storage.Volume.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.LocalDiskVolumeSource","title":"LocalDiskVolumeSource","text":"<p> (Appears on:VolumeSource) </p> <p>LocalDiskVolumeSource is a volume that\u2019s offered by the machine pool provider. Usually ephemeral (i.e. deleted when the surrounding entity is deleted), with varying performance characteristics. Potentially not recoverable.</p> Field Description <code>sizeLimit</code>  k8s.io/apimachinery/pkg/api/resource.Quantity  <p>SizeLimit is the total amount of local storage required for this LocalDisk volume. The default is nil which means that the limit is undefined.</p> <code>image</code>  string  (Optional) <p>Image is the optional URL providing the operating system image of the machine.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachineExecOptions","title":"MachineExecOptions","text":"<p>MachineExecOptions is the query options to a Machine\u2019s remote exec call</p> Field Description <code>insecureSkipTLSVerifyBackend</code>  bool"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachinePoolAddress","title":"MachinePoolAddress","text":"<p> (Appears on:MachinePoolStatus) </p> Field Description <code>type</code>  MachinePoolAddressType  <code>address</code>  string"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachinePoolAddressType","title":"MachinePoolAddressType (<code>string</code> alias)","text":"<p> (Appears on:MachinePoolAddress) </p> Value Description <p>\"ExternalDNS\"</p> <p>MachinePoolExternalDNS identifies a DNS name which resolves to an IP address which has the characteristics of MachinePoolExternalIP. The IP it resolves to may or may not be a listed MachineExternalIP address.</p> <p>\"ExternalIP\"</p> <p>MachinePoolExternalIP identifies an IP address which is, in some way, intended to be more usable from outside the cluster than an internal IP, though no specific semantics are defined.</p> <p>\"Hostname\"</p> <p>MachinePoolHostName identifies a name of the machine pool. Although every machine pool can be assumed to have a MachinePoolAddress of this type, its exact syntax and semantics are not defined, and are not consistent between different clusters.</p> <p>\"InternalDNS\"</p> <p>MachinePoolInternalDNS identifies a DNS name which resolves to an IP address which has the characteristics of a MachinePoolInternalIP. The IP it resolves to may or may not be a listed MachinePoolInternalIP address.</p> <p>\"InternalIP\"</p> <p>MachinePoolInternalIP identifies an IP address which may not be visible to hosts outside the cluster. By default, it is assumed that ironcore-apiserver can reach machine pool internal IPs, though it is possible to configure clusters where this is not the case.</p> <p>MachinePoolInternalIP is the default type of machine pool IP, and does not necessarily imply that the IP is ONLY reachable internally. If a machine pool has multiple internal IPs, no specific semantics are assigned to the additional IPs.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachinePoolCondition","title":"MachinePoolCondition","text":"<p> (Appears on:MachinePoolStatus) </p> <p>MachinePoolCondition is one of the conditions of a volume.</p> Field Description <code>type</code>  MachinePoolConditionType  <p>Type is the type of the condition.</p> <code>status</code>  Kubernetes core/v1.ConditionStatus  <p>Status is the status of the condition.</p> <code>reason</code>  string  <p>Reason is a machine-readable indication of why the condition is in a certain state.</p> <code>message</code>  string  <p>Message is a human-readable explanation of why the condition has a certain reason / state.</p> <code>observedGeneration</code>  int64  <p>ObservedGeneration represents the .metadata.generation that the condition was set based upon.</p> <code>lastTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastTransitionTime is the last time the status of a condition has transitioned from one state to another.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachinePoolConditionType","title":"MachinePoolConditionType (<code>string</code> alias)","text":"<p> (Appears on:MachinePoolCondition) </p> <p>MachinePoolConditionType is a type a MachinePoolCondition can have.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachinePoolDaemonEndpoints","title":"MachinePoolDaemonEndpoints","text":"<p> (Appears on:MachinePoolStatus) </p> <p>MachinePoolDaemonEndpoints lists ports opened by daemons running on the MachinePool.</p> Field Description <code>machinepoolletEndpoint</code>  DaemonEndpoint  (Optional) <p>Endpoint on which machinepoollet is listening.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachinePoolSpec","title":"MachinePoolSpec","text":"<p> (Appears on:MachinePool) </p> <p>MachinePoolSpec defines the desired state of MachinePool</p> Field Description <code>providerID</code>  string  <p>ProviderID identifies the MachinePool on provider side.</p> <code>taints</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Taint  <p>Taints of the MachinePool. Only Machines who tolerate all the taints will land in the MachinePool.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachinePoolState","title":"MachinePoolState (<code>string</code> alias)","text":"<p> (Appears on:MachinePoolStatus) </p> <p>MachinePoolState is a state a MachinePool can be in.</p> Value Description <p>\"Error\"</p> <p>MachinePoolStateError marks a MachinePool in an error state.</p> <p>\"Offline\"</p> <p>MachinePoolStateOffline marks a MachinePool as offline.</p> <p>\"Pending\"</p> <p>MachinePoolStatePending marks a MachinePool as pending readiness.</p> <p>\"Ready\"</p> <p>MachinePoolStateReady marks a MachinePool as ready for accepting a Machine.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachinePoolStatus","title":"MachinePoolStatus","text":"<p> (Appears on:MachinePool) </p> <p>MachinePoolStatus defines the observed state of MachinePool</p> Field Description <code>state</code>  MachinePoolState  <code>conditions</code>  []MachinePoolCondition  <code>availableMachineClasses</code>  []Kubernetes core/v1.LocalObjectReference  <code>addresses</code>  []MachinePoolAddress  <code>daemonEndpoints</code>  MachinePoolDaemonEndpoints  <code>capacity</code>  github.com/ironcore-dev/ironcore/api/core/v1alpha1.ResourceList  <p>Capacity represents the total resources of a machine pool.</p> <code>allocatable</code>  github.com/ironcore-dev/ironcore/api/core/v1alpha1.ResourceList  <p>Allocatable represents the resources of a machine pool that are available for scheduling.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachineSpec","title":"MachineSpec","text":"<p> (Appears on:Machine) </p> <p>MachineSpec defines the desired state of Machine</p> Field Description <code>machineClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>MachineClassRef is a reference to the machine class/flavor of the machine.</p> <code>machinePoolSelector</code>  map[string]string  <p>MachinePoolSelector selects a suitable MachinePoolRef by the given labels.</p> <code>machinePoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>MachinePoolRef defines machine pool to run the machine in. If empty, a scheduler will figure out an appropriate pool to run the machine in.</p> <code>power</code>  Power  <p>Power is the desired machine power state. Defaults to PowerOn.</p> <code>image</code>  string  (Optional) <p>Deprecated: Use LocalDisk to provide a bootable disk Image is the optional URL providing the operating system image of the machine.</p> <code>imagePullSecret</code>  Kubernetes core/v1.LocalObjectReference  <p>ImagePullSecretRef is an optional secret for pulling the image of a machine.</p> <code>networkInterfaces</code>  []NetworkInterface  (Optional) <p>NetworkInterfaces define a list of network interfaces present on the machine</p> <code>volumes</code>  []Volume  (Optional) <p>Volumes are volumes attached to this machine.</p> <code>ignitionRef</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.SecretKeySelector  <p>IgnitionRef is a reference to a secret containing the ignition YAML for the machine to boot up. If key is empty, DefaultIgnitionKey will be used as fallback.</p> <code>efiVars</code>  []EFIVar  (Optional) <p>EFIVars are variables to pass to EFI while booting up.</p> <code>tolerations</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Machine has. Only MachinePools whose taints covered by Tolerations will be considered to run the Machine.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachineState","title":"MachineState (<code>string</code> alias)","text":"<p> (Appears on:MachineStatus) </p> <p>MachineState is the state of a machine.</p> Value Description <p>\"Pending\"</p> <p>MachineStatePending means the Machine has been accepted by the system, but not yet completely started. This includes time before being bound to a MachinePool, as well as time spent setting up the Machine on that MachinePool.</p> <p>\"Running\"</p> <p>MachineStateRunning means the machine is running on a MachinePool.</p> <p>\"Shutdown\"</p> <p>MachineStateShutdown means the machine is shut down.</p> <p>\"Terminated\"</p> <p>MachineStateTerminated means the machine has been permanently stopped and cannot be started.</p> <p>\"Terminating\"</p> <p>MachineStateTerminating means the machine that is terminating.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.MachineStatus","title":"MachineStatus","text":"<p> (Appears on:Machine) </p> <p>MachineStatus defines the observed state of Machine</p> Field Description <code>machineID</code>  string  <p>MachineID is the provider specific machine ID in the format \u2018TYPE://MACHINE_ID\u2019.</p> <code>observedGeneration</code>  int64  <p>ObservedGeneration is the last generation the MachinePool observed of the Machine.</p> <code>state</code>  MachineState  <p>State is the infrastructure state of the machine.</p> <code>networkInterfaces</code>  []NetworkInterfaceStatus  <p>NetworkInterfaces is the list of network interface states for the machine.</p> <code>volumes</code>  []VolumeStatus  <p>Volumes is the list of volume states for the machine.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.NetworkInterface","title":"NetworkInterface","text":"<p> (Appears on:MachineSpec) </p> <p>NetworkInterface is the definition of a single interface</p> Field Description <code>name</code>  string  <p>Name is the name of the network interface.</p> <code>NetworkInterfaceSource</code>  NetworkInterfaceSource  <p> (Members of <code>NetworkInterfaceSource</code> are embedded into this type.) </p> <p>NetworkInterfaceSource is where to obtain the interface from.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.NetworkInterfaceSource","title":"NetworkInterfaceSource","text":"<p> (Appears on:NetworkInterface) </p> Field Description <code>networkInterfaceRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkInterfaceRef instructs to use the NetworkInterface at the target reference.</p> <code>ephemeral</code>  EphemeralNetworkInterfaceSource  <p>Ephemeral instructs to create an ephemeral (i.e. coupled to the lifetime of the surrounding object) NetworkInterface to use.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.NetworkInterfaceState","title":"NetworkInterfaceState (<code>string</code> alias)","text":"<p> (Appears on:NetworkInterfaceStatus) </p> <p>NetworkInterfaceState is the infrastructure attachment state a NetworkInterface can be in.</p> Value Description <p>\"Attached\"</p> <p>NetworkInterfaceStateAttached indicates that a network interface has been successfully attached.</p> <p>\"Pending\"</p> <p>NetworkInterfaceStatePending indicates that the attachment of a network interface is pending.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.NetworkInterfaceStatus","title":"NetworkInterfaceStatus","text":"<p> (Appears on:MachineStatus) </p> <p>NetworkInterfaceStatus reports the status of a NetworkInterfaceSource.</p> Field Description <code>name</code>  string  <p>Name is the name of the NetworkInterface to whom the status belongs to.</p> <code>handle</code>  string  <p>Handle is the MachinePool internal handle of the NetworkInterface.</p> <code>state</code>  NetworkInterfaceState  <p>State represents the attachment state of a NetworkInterface.</p> <code>networkInterfaceRef</code>  Kubernetes core/v1.LocalObjectReference  <p>networkInterfaceRef is the reference to the networkinterface attached to the machine</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.Power","title":"Power (<code>string</code> alias)","text":"<p> (Appears on:MachineSpec) </p> <p>Power is the desired power state of a Machine.</p> Value Description <p>\"Off\"</p> <p>PowerOff indicates that a Machine should be powered off.</p> <p>\"On\"</p> <p>PowerOn indicates that a Machine should be powered on.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.Volume","title":"Volume","text":"<p> (Appears on:MachineSpec) </p> <p>Volume defines a volume attachment of a machine</p> Field Description <code>name</code>  string  <p>Name is the name of the Volume</p> <code>device</code>  string  <p>Device is the device name where the volume should be attached. Pointer to distinguish between explicit zero and not specified. If empty, an unused device name will be determined if possible.</p> <code>VolumeSource</code>  VolumeSource  <p> (Members of <code>VolumeSource</code> are embedded into this type.) </p> <p>VolumeSource is the source where the storage for the Volume resides at.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.VolumeSource","title":"VolumeSource","text":"<p> (Appears on:Volume) </p> <p>VolumeSource specifies the source to use for a Volume.</p> Field Description <code>volumeRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumeRef instructs to use the specified Volume as source for the attachment.</p> <code>emptyDisk</code>  EmptyDiskVolumeSource  <p>Deprecated: Use LocalDisk instead EmptyDisk instructs to use a Volume offered by the machine pool provider.</p> <code>localDisk</code>  LocalDiskVolumeSource  <p>LocalDisk instructs to use a Volume offered by the machine pool provider.</p> <code>ephemeral</code>  EphemeralVolumeSource  <p>Ephemeral instructs to create an ephemeral (i.e. coupled to the lifetime of the surrounding object) Volume to use.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.VolumeState","title":"VolumeState (<code>string</code> alias)","text":"<p> (Appears on:VolumeStatus) </p> <p>VolumeState is the infrastructure attachment state a Volume can be in.</p> Value Description <p>\"Attached\"</p> <p>VolumeStateAttached indicates that a volume has been successfully attached.</p> <p>\"Pending\"</p> <p>VolumeStatePending indicates that the attachment of a volume is pending.</p>"},{"location":"api-reference/compute/#compute.ironcore.dev/v1alpha1.VolumeStatus","title":"VolumeStatus","text":"<p> (Appears on:MachineStatus) </p> <p>VolumeStatus is the status of a Volume.</p> Field Description <code>name</code>  string  <p>Name is the name of a volume attachment.</p> <code>handle</code>  string  <p>Handle is the MachinePool internal handle of the volume.</p> <code>state</code>  VolumeState  <p>State represents the attachment state of a Volume.</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned.</p> <code>volumeRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumeRef reference to the claimed Volume</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"api-reference/core/","title":"Core","text":"<p>Packages:</p> <ul> <li> core.ironcore.dev/v1alpha1 </li> </ul>"},{"location":"api-reference/core/#core.ironcore.dev/v1alpha1","title":"core.ironcore.dev/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p> <ul><li> ResourceQuota </li></ul>"},{"location":"api-reference/core/#core.ironcore.dev/v1alpha1.ResourceQuota","title":"ResourceQuota","text":"<p>ResourceQuota is the Schema for the resourcequotas API</p> Field Description <code>apiVersion</code> string <code> core.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>ResourceQuota</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  ResourceQuotaSpec  <code>hard</code>  ResourceList  <p>Hard is a ResourceList of the strictly enforced amount of resources.</p> <code>scopeSelector</code>  ResourceScopeSelector  <p>ScopeSelector selects the resources that are subject to this quota. Note: By using certain ScopeSelectors, only certain resources may be tracked.</p> <code>status</code>  ResourceQuotaStatus"},{"location":"api-reference/core/#core.ironcore.dev/v1alpha1.ClassType","title":"ClassType (<code>string</code> alias)","text":"Value Description <p>\"machine\"</p> <p>\"volume\"</p>"},{"location":"api-reference/core/#core.ironcore.dev/v1alpha1.ObjectSelector","title":"ObjectSelector","text":"<p>ObjectSelector specifies how to select objects of a certain kind.</p> Field Description <code>kind</code>  string  <p>Kind is the kind of object to select.</p> <code>LabelSelector</code>  Kubernetes meta/v1.LabelSelector  <p> (Members of <code>LabelSelector</code> are embedded into this type.) </p> <p>LabelSelector is the label selector to select objects of the specified Kind by.</p>"},{"location":"api-reference/core/#core.ironcore.dev/v1alpha1.ResourceName","title":"ResourceName (<code>string</code> alias)","text":"<p>ResourceName is the name of a resource, most often used alongside a resource.Quantity.</p> Value Description <p>\"cpu\"</p> <p>ResourceCPU is the amount of cpu in cores.</p> <p>\"iops\"</p> <p>ResourceIOPS defines max IOPS in input/output operations per second.</p> <p>\"memory\"</p> <p>ResourceMemory is the amount of memory in bytes.</p> <p>\"requests.cpu\"</p> <p>ResourceRequestsCPU is the amount of requested cpu in cores.</p> <p>\"requests.iops\"</p> <p>ResourceRequestsIOPS is the amount of requested IOPS in input/output operations per second.</p> <p>\"requests.memory\"</p> <p>ResourceRequestsMemory is the amount of requested memory in bytes.</p> <p>\"requests.storage\"</p> <p>ResourceRequestsStorage is the amount of requested storage in bytes.</p> <p>\"requests.tps\"</p> <p>ResourceRequestsTPS is the amount of requested throughput per second.</p> <p>\"storage\"</p> <p>ResourceStorage is the amount of storage, in bytes.</p> <p>\"tps\"</p> <p>ResourceTPS defines max throughput per second. (e.g. 1Gi)</p>"},{"location":"api-reference/core/#core.ironcore.dev/v1alpha1.ResourceQuotaSpec","title":"ResourceQuotaSpec","text":"<p> (Appears on:ResourceQuota) </p> <p>ResourceQuotaSpec defines the desired state of ResourceQuotaSpec</p> Field Description <code>hard</code>  ResourceList  <p>Hard is a ResourceList of the strictly enforced amount of resources.</p> <code>scopeSelector</code>  ResourceScopeSelector  <p>ScopeSelector selects the resources that are subject to this quota. Note: By using certain ScopeSelectors, only certain resources may be tracked.</p>"},{"location":"api-reference/core/#core.ironcore.dev/v1alpha1.ResourceQuotaStatus","title":"ResourceQuotaStatus","text":"<p> (Appears on:ResourceQuota) </p> <p>ResourceQuotaStatus is the status of a ResourceQuota.</p> Field Description <code>hard</code>  ResourceList  <p>Hard are the currently enforced hard resource limits. Hard may be less than used in case the limits were introduced / updated after more than allowed resources were already present.</p> <code>used</code>  ResourceList  <p>Used is the amount of currently used resources.</p>"},{"location":"api-reference/core/#core.ironcore.dev/v1alpha1.ResourceScope","title":"ResourceScope (<code>string</code> alias)","text":"<p> (Appears on:ResourceScopeSelectorRequirement) </p> <p>ResourceScope is a scope of a resource.</p> Value Description <p>\"BucketClass\"</p> <p>ResourceScopeBucketClass refers to the bucket class of a resource.</p> <p>\"MachineClass\"</p> <p>ResourceScopeMachineClass refers to the machine class of a resource.</p> <p>\"VolumeClass\"</p> <p>ResourceScopeVolumeClass refers to the volume class of a resource.</p>"},{"location":"api-reference/core/#core.ironcore.dev/v1alpha1.ResourceScopeSelector","title":"ResourceScopeSelector","text":"<p> (Appears on:ResourceQuotaSpec) </p> <p>ResourceScopeSelector selects</p> Field Description <code>matchExpressions</code>  []ResourceScopeSelectorRequirement  <p>MatchExpressions is a list of ResourceScopeSelectorRequirement to match resources by.</p>"},{"location":"api-reference/core/#core.ironcore.dev/v1alpha1.ResourceScopeSelectorOperator","title":"ResourceScopeSelectorOperator (<code>string</code> alias)","text":"<p> (Appears on:ResourceScopeSelectorRequirement) </p> <p>ResourceScopeSelectorOperator is an operator to compare a ResourceScope with values.</p> Value Description <p>\"DoesNotExist\"</p> <p>\"Exists\"</p> <p>\"In\"</p> <p>\"NotIn\"</p>"},{"location":"api-reference/core/#core.ironcore.dev/v1alpha1.ResourceScopeSelectorRequirement","title":"ResourceScopeSelectorRequirement","text":"<p> (Appears on:ResourceScopeSelector) </p> <p>ResourceScopeSelectorRequirement is a requirement for a resource using a ResourceScope alongside a ResourceScopeSelectorOperator with Values (depending on the ResourceScopeSelectorOperator).</p> Field Description <code>scopeName</code>  ResourceScope  <p>ScopeName is the ResourceScope to make a requirement for.</p> <code>operator</code>  ResourceScopeSelectorOperator  <p>Operator is the ResourceScopeSelectorOperator to check the ScopeName with in a resource.</p> <code>values</code>  []string  <p>Values are the values to compare the Operator with the ScopeName. May be optional.</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"api-reference/ipam/","title":"IPAM","text":"<p>Packages:</p> <ul> <li> ipam.ironcore.dev/v1alpha1 </li> </ul>"},{"location":"api-reference/ipam/#ipam.ironcore.dev/v1alpha1","title":"ipam.ironcore.dev/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p> <ul><li> Prefix </li><li> PrefixAllocation </li></ul>"},{"location":"api-reference/ipam/#ipam.ironcore.dev/v1alpha1.Prefix","title":"Prefix","text":"<p>Prefix is the Schema for the prefixes API</p> Field Description <code>apiVersion</code> string <code> ipam.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>Prefix</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  PrefixSpec  <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the IPFamily of the prefix. If unset but Prefix is set, this can be inferred.</p> <code>prefix</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>Prefix is the prefix to allocate for this Prefix.</p> <code>prefixLength</code>  int32  <p>PrefixLength is the length of prefix to allocate for this Prefix.</p> <code>parentRef</code>  Kubernetes core/v1.LocalObjectReference  <p>ParentRef references the parent to allocate the Prefix from. If ParentRef and ParentSelector is empty, the Prefix is considered a root prefix and thus allocated by itself.</p> <code>parentSelector</code>  Kubernetes meta/v1.LabelSelector  <p>ParentSelector is the LabelSelector to use for determining the parent for this Prefix.</p> <code>status</code>  PrefixStatus"},{"location":"api-reference/ipam/#ipam.ironcore.dev/v1alpha1.PrefixAllocation","title":"PrefixAllocation","text":"<p>PrefixAllocation is the Schema for the prefixallocations API</p> Field Description <code>apiVersion</code> string <code> ipam.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>PrefixAllocation</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  PrefixAllocationSpec  <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the IPFamily of the prefix. If unset but Prefix is set, this can be inferred.</p> <code>prefix</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>Prefix is the prefix to allocate for this Prefix.</p> <code>prefixLength</code>  int32  <p>PrefixLength is the length of prefix to allocate for this Prefix.</p> <code>prefixRef</code>  Kubernetes core/v1.LocalObjectReference  <p>PrefixRef references the prefix to allocate from.</p> <code>prefixSelector</code>  Kubernetes meta/v1.LabelSelector  <p>PrefixSelector selects the prefix to allocate from.</p> <code>status</code>  PrefixAllocationStatus"},{"location":"api-reference/ipam/#ipam.ironcore.dev/v1alpha1.PrefixAllocationPhase","title":"PrefixAllocationPhase (<code>string</code> alias)","text":"<p> (Appears on:PrefixAllocationStatus) </p> <p>PrefixAllocationPhase is a phase a PrefixAllocation can be in.</p> Value Description <p>\"Allocated\"</p> <p>PrefixAllocationPhaseAllocated marks a PrefixAllocation as allocated by a Prefix.</p> <p>\"Failed\"</p> <p>PrefixAllocationPhaseFailed marks a PrefixAllocation as failed.</p> <p>\"Pending\"</p> <p>PrefixAllocationPhasePending marks a PrefixAllocation as waiting for allocation.</p>"},{"location":"api-reference/ipam/#ipam.ironcore.dev/v1alpha1.PrefixAllocationSpec","title":"PrefixAllocationSpec","text":"<p> (Appears on:PrefixAllocation) </p> <p>PrefixAllocationSpec defines the desired state of PrefixAllocation</p> Field Description <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the IPFamily of the prefix. If unset but Prefix is set, this can be inferred.</p> <code>prefix</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>Prefix is the prefix to allocate for this Prefix.</p> <code>prefixLength</code>  int32  <p>PrefixLength is the length of prefix to allocate for this Prefix.</p> <code>prefixRef</code>  Kubernetes core/v1.LocalObjectReference  <p>PrefixRef references the prefix to allocate from.</p> <code>prefixSelector</code>  Kubernetes meta/v1.LabelSelector  <p>PrefixSelector selects the prefix to allocate from.</p>"},{"location":"api-reference/ipam/#ipam.ironcore.dev/v1alpha1.PrefixAllocationStatus","title":"PrefixAllocationStatus","text":"<p> (Appears on:PrefixAllocation) </p> <p>PrefixAllocationStatus is the status of a PrefixAllocation.</p> Field Description <code>prefix</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>Prefix is the allocated prefix, if any</p> <code>phase</code>  PrefixAllocationPhase  <p>Phase is the phase of the PrefixAllocation.</p> <code>lastPhaseTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastPhaseTransitionTime is the last time the Phase changed values.</p>"},{"location":"api-reference/ipam/#ipam.ironcore.dev/v1alpha1.PrefixPhase","title":"PrefixPhase (<code>string</code> alias)","text":"<p> (Appears on:PrefixStatus) </p> <p>PrefixPhase is a phase a Prefix can be in.</p> Value Description <p>\"Allocated\"</p> <p>PrefixPhaseAllocated marks a prefix as allocated.</p> <p>\"Pending\"</p> <p>PrefixPhasePending marks a prefix as waiting for allocation.</p>"},{"location":"api-reference/ipam/#ipam.ironcore.dev/v1alpha1.PrefixSpec","title":"PrefixSpec","text":"<p> (Appears on:Prefix, PrefixTemplateSpec) </p> <p>PrefixSpec defines the desired state of Prefix</p> Field Description <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the IPFamily of the prefix. If unset but Prefix is set, this can be inferred.</p> <code>prefix</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>Prefix is the prefix to allocate for this Prefix.</p> <code>prefixLength</code>  int32  <p>PrefixLength is the length of prefix to allocate for this Prefix.</p> <code>parentRef</code>  Kubernetes core/v1.LocalObjectReference  <p>ParentRef references the parent to allocate the Prefix from. If ParentRef and ParentSelector is empty, the Prefix is considered a root prefix and thus allocated by itself.</p> <code>parentSelector</code>  Kubernetes meta/v1.LabelSelector  <p>ParentSelector is the LabelSelector to use for determining the parent for this Prefix.</p>"},{"location":"api-reference/ipam/#ipam.ironcore.dev/v1alpha1.PrefixStatus","title":"PrefixStatus","text":"<p> (Appears on:Prefix) </p> <p>PrefixStatus defines the observed state of Prefix</p> Field Description <code>phase</code>  PrefixPhase  <p>Phase is the PrefixPhase of the Prefix.</p> <code>lastPhaseTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastPhaseTransitionTime is the last time the Phase changed values.</p> <code>used</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>Used is a list of used prefixes.</p>"},{"location":"api-reference/ipam/#ipam.ironcore.dev/v1alpha1.PrefixTemplateSpec","title":"PrefixTemplateSpec","text":"Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  PrefixSpec  <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the IPFamily of the prefix. If unset but Prefix is set, this can be inferred.</p> <code>prefix</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>Prefix is the prefix to allocate for this Prefix.</p> <code>prefixLength</code>  int32  <p>PrefixLength is the length of prefix to allocate for this Prefix.</p> <code>parentRef</code>  Kubernetes core/v1.LocalObjectReference  <p>ParentRef references the parent to allocate the Prefix from. If ParentRef and ParentSelector is empty, the Prefix is considered a root prefix and thus allocated by itself.</p> <code>parentSelector</code>  Kubernetes meta/v1.LabelSelector  <p>ParentSelector is the LabelSelector to use for determining the parent for this Prefix.</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"api-reference/networking/","title":"Networking","text":"<p>Packages:</p> <ul> <li> networking.ironcore.dev/v1alpha1 </li> </ul>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1","title":"networking.ironcore.dev/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p> <ul><li> LoadBalancer </li><li> LoadBalancerRouting </li><li> NATGateway </li><li> Network </li><li> NetworkInterface </li><li> NetworkPolicy </li><li> VirtualIP </li></ul>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.LoadBalancer","title":"LoadBalancer","text":"<p>LoadBalancer is the Schema for the LoadBalancer API</p> Field Description <code>apiVersion</code> string <code> networking.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>LoadBalancer</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  LoadBalancerSpec  <code>type</code>  LoadBalancerType  <p>Type is the type of LoadBalancer.</p> <code>ipFamilies</code>  []Kubernetes core/v1.IPFamily  <p>IPFamilies are the ip families the load balancer should have.</p> <code>ips</code>  []IPSource  <p>IPs are the ips to use. Can only be used when Type is LoadBalancerTypeInternal.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this LoadBalancer should belong to.</p> <code>networkInterfaceSelector</code>  Kubernetes meta/v1.LabelSelector  <p>NetworkInterfaceSelector defines the NetworkInterfaces for which this LoadBalancer should be applied</p> <code>ports</code>  []LoadBalancerPort  <p>Ports are the ports the load balancer should allow.</p> <code>status</code>  LoadBalancerStatus"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.LoadBalancerRouting","title":"LoadBalancerRouting","text":"<p>LoadBalancerRouting is the Schema for the loadbalancerroutings API</p> Field Description <code>apiVersion</code> string <code> networking.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>LoadBalancerRouting</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>networkRef</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.LocalUIDReference  <p>NetworkRef is the network the load balancer is assigned to.</p> <code>destinations</code>  []LoadBalancerDestination  <p>Destinations are the destinations for a LoadBalancer.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NATGateway","title":"NATGateway","text":"<p>NATGateway is the Schema for the NATGateway API</p> Field Description <code>apiVersion</code> string <code> networking.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>NATGateway</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NATGatewaySpec  <code>type</code>  NATGatewayType  <p>Type is the type of NATGateway.</p> <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the ip family the NAT gateway should have.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this NATGateway should belong to.</p> <code>portsPerNetworkInterface</code>  int32  <p>PortsPerNetworkInterface defines the number of concurrent connections per target network interface. Has to be a power of 2. If empty, 2048 (DefaultPortsPerNetworkInterface) is the default.</p> <code>status</code>  NATGatewayStatus"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.Network","title":"Network","text":"<p>Network is the Schema for the network API</p> Field Description <code>apiVersion</code> string <code> networking.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>Network</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NetworkSpec  <code>providerID</code>  string  <p>ProviderID is the provider-internal ID of the network.</p> <code>peerings</code>  []NetworkPeering  (Optional) <p>Peerings are the network peerings with this network.</p> <code>incomingPeerings</code>  []NetworkPeeringClaimRef  (Optional) <p>PeeringClaimRefs are the peering claim references of other networks.</p> <code>status</code>  NetworkStatus"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkInterface","title":"NetworkInterface","text":"<p>NetworkInterface is the Schema for the networkinterfaces API</p> Field Description <code>apiVersion</code> string <code> networking.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>NetworkInterface</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NetworkInterfaceSpec  <code>providerID</code>  string  <p>ProviderID is the provider-internal ID of the network interface.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this NetworkInterface is connected to</p> <code>machineRef</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.LocalUIDReference  <p>MachineRef is the Machine this NetworkInterface is used by</p> <code>ipFamilies</code>  []Kubernetes core/v1.IPFamily  <p>IPFamilies defines which IPFamilies this NetworkInterface is supporting</p> <code>ips</code>  []IPSource  <p>IPs is the list of provided IPs or ephemeral IPs which should be assigned to this NetworkInterface.</p> <code>prefixes</code>  []PrefixSource  <p>Prefixes is the list of provided prefixes or ephemeral prefixes which should be assigned to this NetworkInterface.</p> <code>virtualIP</code>  VirtualIPSource  <p>VirtualIP specifies the virtual ip that should be assigned to this NetworkInterface.</p> <code>attributes</code>  map[string]string  <p>Attributes are provider-specific attributes for the network interface.</p> <code>status</code>  NetworkInterfaceStatus"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPolicy","title":"NetworkPolicy","text":"<p>NetworkPolicy is the Schema for the networkpolicies API</p> Field Description <code>apiVersion</code> string <code> networking.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>NetworkPolicy</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NetworkPolicySpec  <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the network to regulate using this policy.</p> <code>networkInterfaceSelector</code>  Kubernetes meta/v1.LabelSelector  <p>NetworkInterfaceSelector selects the network interfaces that are subject to this policy.</p> <code>ingress</code>  []NetworkPolicyIngressRule  <p>Ingress specifies rules for ingress traffic.</p> <code>egress</code>  []NetworkPolicyEgressRule  <p>Egress specifies rules for egress traffic.</p> <code>policyTypes</code>  []PolicyType  <p>PolicyTypes specifies the types of policies this network policy contains.</p> <code>status</code>  NetworkPolicyStatus"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.VirtualIP","title":"VirtualIP","text":"<p>VirtualIP is the Schema for the virtualips API</p> Field Description <code>apiVersion</code> string <code> networking.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>VirtualIP</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  VirtualIPSpec  <code>type</code>  VirtualIPType  <p>Type is the type of VirtualIP.</p> <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the ip family of the VirtualIP.</p> <code>targetRef</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.LocalUIDReference  <p>TargetRef references the target for this VirtualIP (currently only NetworkInterface).</p> <code>status</code>  VirtualIPStatus"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.EphemeralPrefixSource","title":"EphemeralPrefixSource","text":"<p> (Appears on:IPSource, PrefixSource) </p> <p>EphemeralPrefixSource contains the definition to create an ephemeral (i.e. coupled to the lifetime of the surrounding object) Prefix.</p> Field Description <code>prefixTemplate</code>  github.com/ironcore-dev/ironcore/api/ipam/v1alpha1.PrefixTemplateSpec  <p>PrefixTemplate is the template for the Prefix.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.EphemeralVirtualIPSource","title":"EphemeralVirtualIPSource","text":"<p> (Appears on:VirtualIPSource) </p> <p>EphemeralVirtualIPSource contains the definition to create an ephemeral (i.e. coupled to the lifetime of the surrounding object) VirtualIP.</p> Field Description <code>virtualIPTemplate</code>  VirtualIPTemplateSpec  <p>VirtualIPTemplate is the template for the VirtualIP.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.EphemeralVirtualIPSpec","title":"EphemeralVirtualIPSpec","text":"<p> (Appears on:VirtualIPTemplateSpec) </p> Field Description <code>VirtualIPSpec</code>  VirtualIPSpec  <p> (Members of <code>VirtualIPSpec</code> are embedded into this type.) </p> <p>VirtualIPSpec defines the desired state of a VirtualIP</p> <code>reclaimPolicy</code>  ReclaimPolicyType  <p>ReclaimPolicy is the ReclaimPolicyType of virtualIP</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.IPBlock","title":"IPBlock","text":"<p> (Appears on:NetworkPolicyPeer) </p> <p>IPBlock specifies an ip block with optional exceptions.</p> Field Description <code>cidr</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>CIDR is a string representing the ip block.</p> <code>except</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>Except is a slice of CIDRs that should not be included within the specified CIDR. Values will be rejected if they are outside CIDR.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.IPSource","title":"IPSource","text":"<p> (Appears on:LoadBalancerSpec, NetworkInterfaceSpec) </p> <p>IPSource is the definition of how to obtain an IP.</p> Field Description <code>value</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IP  <p>Value specifies an IP by using an IP literal.</p> <code>ephemeral</code>  EphemeralPrefixSource  <p>Ephemeral specifies an IP by creating an ephemeral Prefix to allocate the IP with.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.LoadBalancerDestination","title":"LoadBalancerDestination","text":"<p> (Appears on:LoadBalancerRouting) </p> <p>LoadBalancerDestination is the destination of the load balancer.</p> Field Description <code>ip</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IP  <p>IP is the target IP.</p> <code>targetRef</code>  LoadBalancerTargetRef  <p>TargetRef is the target providing the destination.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.LoadBalancerPort","title":"LoadBalancerPort","text":"<p> (Appears on:LoadBalancerSpec) </p> Field Description <code>protocol</code>  Kubernetes core/v1.Protocol  <p>Protocol is the protocol the load balancer should allow. If not specified, defaults to TCP.</p> <code>port</code>  int32  <p>Port is the port to allow.</p> <code>endPort</code>  int32  <p>EndPort marks the end of the port range to allow. If unspecified, only a single port, Port, will be allowed.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.LoadBalancerSpec","title":"LoadBalancerSpec","text":"<p> (Appears on:LoadBalancer) </p> <p>LoadBalancerSpec defines the desired state of LoadBalancer</p> Field Description <code>type</code>  LoadBalancerType  <p>Type is the type of LoadBalancer.</p> <code>ipFamilies</code>  []Kubernetes core/v1.IPFamily  <p>IPFamilies are the ip families the load balancer should have.</p> <code>ips</code>  []IPSource  <p>IPs are the ips to use. Can only be used when Type is LoadBalancerTypeInternal.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this LoadBalancer should belong to.</p> <code>networkInterfaceSelector</code>  Kubernetes meta/v1.LabelSelector  <p>NetworkInterfaceSelector defines the NetworkInterfaces for which this LoadBalancer should be applied</p> <code>ports</code>  []LoadBalancerPort  <p>Ports are the ports the load balancer should allow.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.LoadBalancerStatus","title":"LoadBalancerStatus","text":"<p> (Appears on:LoadBalancer) </p> <p>LoadBalancerStatus defines the observed state of LoadBalancer</p> Field Description <code>ips</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.IP  <p>IPs are the IPs allocated for the load balancer.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.LoadBalancerTargetRef","title":"LoadBalancerTargetRef","text":"<p> (Appears on:LoadBalancerDestination) </p> <p>LoadBalancerTargetRef is a load balancer target.</p> Field Description <code>uid</code>  k8s.io/apimachinery/pkg/types.UID  <p>UID is the UID of the target.</p> <code>name</code>  string  <p>Name is the name of the target.</p> <code>providerID</code>  string  <p>ProviderID is the provider internal id of the target.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.LoadBalancerType","title":"LoadBalancerType (<code>string</code> alias)","text":"<p> (Appears on:LoadBalancerSpec) </p> <p>LoadBalancerType is a type of LoadBalancer.</p> Value Description <p>\"Internal\"</p> <p>LoadBalancerTypeInternal is a LoadBalancer that allocates and routes network-internal, stable IPs.</p> <p>\"Public\"</p> <p>LoadBalancerTypePublic is a LoadBalancer that allocates and routes a stable public IP.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NATGatewaySpec","title":"NATGatewaySpec","text":"<p> (Appears on:NATGateway) </p> <p>NATGatewaySpec defines the desired state of NATGateway</p> Field Description <code>type</code>  NATGatewayType  <p>Type is the type of NATGateway.</p> <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the ip family the NAT gateway should have.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this NATGateway should belong to.</p> <code>portsPerNetworkInterface</code>  int32  <p>PortsPerNetworkInterface defines the number of concurrent connections per target network interface. Has to be a power of 2. If empty, 2048 (DefaultPortsPerNetworkInterface) is the default.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NATGatewayStatus","title":"NATGatewayStatus","text":"<p> (Appears on:NATGateway) </p> <p>NATGatewayStatus defines the observed state of NATGateway</p> Field Description <code>ips</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.IP  <p>IPs are the IPs allocated for the NAT gateway.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NATGatewayType","title":"NATGatewayType (<code>string</code> alias)","text":"<p> (Appears on:NATGatewaySpec) </p> <p>NATGatewayType is a type of NATGateway.</p> Value Description <p>\"Public\"</p> <p>NATGatewayTypePublic is a NATGateway that allocates and routes a stable public IP.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkInterfaceSpec","title":"NetworkInterfaceSpec","text":"<p> (Appears on:NetworkInterface, NetworkInterfaceTemplateSpec) </p> <p>NetworkInterfaceSpec defines the desired state of NetworkInterface</p> Field Description <code>providerID</code>  string  <p>ProviderID is the provider-internal ID of the network interface.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this NetworkInterface is connected to</p> <code>machineRef</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.LocalUIDReference  <p>MachineRef is the Machine this NetworkInterface is used by</p> <code>ipFamilies</code>  []Kubernetes core/v1.IPFamily  <p>IPFamilies defines which IPFamilies this NetworkInterface is supporting</p> <code>ips</code>  []IPSource  <p>IPs is the list of provided IPs or ephemeral IPs which should be assigned to this NetworkInterface.</p> <code>prefixes</code>  []PrefixSource  <p>Prefixes is the list of provided prefixes or ephemeral prefixes which should be assigned to this NetworkInterface.</p> <code>virtualIP</code>  VirtualIPSource  <p>VirtualIP specifies the virtual ip that should be assigned to this NetworkInterface.</p> <code>attributes</code>  map[string]string  <p>Attributes are provider-specific attributes for the network interface.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkInterfaceState","title":"NetworkInterfaceState (<code>string</code> alias)","text":"<p> (Appears on:NetworkInterfaceStatus) </p> <p>NetworkInterfaceState is the ironcore state of a NetworkInterface.</p> Value Description <p>\"Available\"</p> <p>NetworkInterfaceStateAvailable is used for any NetworkInterface where all properties are valid.</p> <p>\"Error\"</p> <p>NetworkInterfaceStateError is used for any NetworkInterface where any property has an error.</p> <p>\"Pending\"</p> <p>NetworkInterfaceStatePending is used for any NetworkInterface that is pending.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkInterfaceStatus","title":"NetworkInterfaceStatus","text":"<p> (Appears on:NetworkInterface) </p> <p>NetworkInterfaceStatus defines the observed state of NetworkInterface</p> Field Description <code>state</code>  NetworkInterfaceState  <p>State is the NetworkInterfaceState of the NetworkInterface.</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned from one value to another.</p> <code>ips</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.IP  <p>IPs represent the effective IP addresses of the NetworkInterface.</p> <code>prefixes</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>Prefixes represent the prefixes routed to the NetworkInterface.</p> <code>virtualIP</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IP  <p>VirtualIP is any virtual ip assigned to the NetworkInterface.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkInterfaceTemplateSpec","title":"NetworkInterfaceTemplateSpec","text":"<p>NetworkInterfaceTemplateSpec is the specification of a NetworkInterface template.</p> Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  NetworkInterfaceSpec  <code>providerID</code>  string  <p>ProviderID is the provider-internal ID of the network interface.</p> <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the Network this NetworkInterface is connected to</p> <code>machineRef</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.LocalUIDReference  <p>MachineRef is the Machine this NetworkInterface is used by</p> <code>ipFamilies</code>  []Kubernetes core/v1.IPFamily  <p>IPFamilies defines which IPFamilies this NetworkInterface is supporting</p> <code>ips</code>  []IPSource  <p>IPs is the list of provided IPs or ephemeral IPs which should be assigned to this NetworkInterface.</p> <code>prefixes</code>  []PrefixSource  <p>Prefixes is the list of provided prefixes or ephemeral prefixes which should be assigned to this NetworkInterface.</p> <code>virtualIP</code>  VirtualIPSource  <p>VirtualIP specifies the virtual ip that should be assigned to this NetworkInterface.</p> <code>attributes</code>  map[string]string  <p>Attributes are provider-specific attributes for the network interface.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPeering","title":"NetworkPeering","text":"<p> (Appears on:NetworkSpec) </p> <p>NetworkPeering defines a network peering with another network.</p> Field Description <code>name</code>  string  <p>Name is the semantical name of the network peering.</p> <code>networkRef</code>  NetworkPeeringNetworkRef  <p>NetworkRef is the reference to the network to peer with. An empty namespace indicates that the target network resides in the same namespace as the source network.</p> <code>prefixes</code>  []PeeringPrefix  <p>Prefixes is a list of prefixes that we want only to be exposed to the peered network, if no prefixes are specified no filtering will be done.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPeeringClaimRef","title":"NetworkPeeringClaimRef","text":"<p> (Appears on:NetworkSpec) </p> Field Description <code>namespace</code>  string  <p>Namespace is the namespace of the referenced entity. If empty, the same namespace as the referring resource is implied.</p> <code>name</code>  string  <p>Name is the name of the referenced entity.</p> <code>uid</code>  k8s.io/apimachinery/pkg/types.UID  <p>UID is the UID of the referenced entity.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPeeringNetworkRef","title":"NetworkPeeringNetworkRef","text":"<p> (Appears on:NetworkPeering) </p> <p>NetworkPeeringNetworkRef is a reference to a network to peer with.</p> Field Description <code>namespace</code>  string  <p>Namespace is the namespace of the referenced entity. If empty, the same namespace as the referring resource is implied.</p> <code>name</code>  string  <p>Name is the name of the referenced entity.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPeeringState","title":"NetworkPeeringState (<code>string</code> alias)","text":"<p> (Appears on:NetworkPeeringStatus) </p> <p>NetworkPeeringState is the state a NetworkPeering can be in</p> Value Description <p>\"Error\"</p> <p>NetworkPeeringStateError signals that the network peering is in error state.</p> <p>\"Pending\"</p> <p>NetworkPeeringStatePending signals that the network peering is not applied.</p> <p>\"Ready\"</p> <p>NetworkPeeringStateReady signals that the network peering is ready.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPeeringStatus","title":"NetworkPeeringStatus","text":"<p> (Appears on:NetworkStatus) </p> <p>NetworkPeeringStatus is the status of a network peering.</p> Field Description <code>name</code>  string  <p>Name is the name of the network peering.</p> <code>state</code>  NetworkPeeringState  <p>State represents the network peering state</p> <code>prefixes</code>  []PeeringPrefixStatus  <p>Prefixes contains the prefixes exposed to the peered network</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPolicyCondition","title":"NetworkPolicyCondition","text":"<p> (Appears on:NetworkPolicyStatus) </p> <p>NetworkPolicyCondition is one of the conditions of a network policy.</p> Field Description <code>type</code>  NetworkPolicyConditionType  <p>Type is the type of the condition.</p> <code>status</code>  Kubernetes core/v1.ConditionStatus  <p>Status is the status of the condition.</p> <code>reason</code>  string  <p>Reason is a machine-readable indication of why the condition is in a certain state.</p> <code>message</code>  string  <p>Message is a human-readable explanation of why the condition has a certain reason / state.</p> <code>observedGeneration</code>  int64  <p>ObservedGeneration represents the .metadata.generation that the condition was set based upon.</p> <code>lastTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastTransitionTime is the last time the status of a condition has transitioned from one state to another.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPolicyConditionType","title":"NetworkPolicyConditionType (<code>string</code> alias)","text":"<p> (Appears on:NetworkPolicyCondition) </p> <p>NetworkPolicyConditionType is a type a NetworkPolicyCondition can have.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPolicyEgressRule","title":"NetworkPolicyEgressRule","text":"<p> (Appears on:NetworkPolicySpec) </p> <p>NetworkPolicyEgressRule describes a rule to regulate egress traffic with.</p> Field Description <code>ports</code>  []NetworkPolicyPort  <p>Ports specifies the list of destination ports that can be called with this rule. Each item in this list is combined using a logical OR. Empty matches all ports. As soon as a single item is present, only these ports are allowed.</p> <code>to</code>  []NetworkPolicyPeer  <p>To specifies the list of destinations which the selected network interfaces should be able to send traffic to. Fields are combined using a logical OR. Empty matches all destinations. As soon as a single item is present, only these peers are allowed.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPolicyIngressRule","title":"NetworkPolicyIngressRule","text":"<p> (Appears on:NetworkPolicySpec) </p> <p>NetworkPolicyIngressRule describes a rule to regulate ingress traffic with.</p> Field Description <code>ports</code>  []NetworkPolicyPort  <p>Ports specifies the list of ports which should be made accessible for this rule. Each item in this list is combined using a logical OR. Empty matches all ports. As soon as a single item is present, only these ports are allowed.</p> <code>from</code>  []NetworkPolicyPeer  <p>From specifies the list of sources which should be able to send traffic to the selected network interfaces. Fields are combined using a logical OR. Empty matches all sources. As soon as a single item is present, only these peers are allowed.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPolicyPeer","title":"NetworkPolicyPeer","text":"<p> (Appears on:NetworkPolicyEgressRule, NetworkPolicyIngressRule) </p> <p>NetworkPolicyPeer describes a peer to allow traffic to / from.</p> Field Description <code>objectSelector</code>  github.com/ironcore-dev/ironcore/api/core/v1alpha1.ObjectSelector  <p>ObjectSelector selects peers with the given kind matching the label selector. Exclusive with other peer specifiers.</p> <code>ipBlock</code>  IPBlock  <p>IPBlock specifies the ip block from or to which network traffic may come.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPolicyPort","title":"NetworkPolicyPort","text":"<p> (Appears on:NetworkPolicyEgressRule, NetworkPolicyIngressRule) </p> <p>NetworkPolicyPort describes a port to allow traffic on</p> Field Description <code>protocol</code>  Kubernetes core/v1.Protocol  <p>Protocol (TCP, UDP, or SCTP) which traffic must match. If not specified, this field defaults to TCP.</p> <code>port</code>  int32  <p>The port on the given protocol. If this field is not provided, this matches all port names and numbers. If present, only traffic on the specified protocol AND port will be matched.</p> <code>endPort</code>  int32  <p>EndPort indicates that the range of ports from Port to EndPort, inclusive, should be allowed by the policy. This field cannot be defined if the port field is not defined. The endPort must be equal or greater than port.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPolicySpec","title":"NetworkPolicySpec","text":"<p> (Appears on:NetworkPolicy) </p> <p>NetworkPolicySpec defines the desired state of NetworkPolicy.</p> Field Description <code>networkRef</code>  Kubernetes core/v1.LocalObjectReference  <p>NetworkRef is the network to regulate using this policy.</p> <code>networkInterfaceSelector</code>  Kubernetes meta/v1.LabelSelector  <p>NetworkInterfaceSelector selects the network interfaces that are subject to this policy.</p> <code>ingress</code>  []NetworkPolicyIngressRule  <p>Ingress specifies rules for ingress traffic.</p> <code>egress</code>  []NetworkPolicyEgressRule  <p>Egress specifies rules for egress traffic.</p> <code>policyTypes</code>  []PolicyType  <p>PolicyTypes specifies the types of policies this network policy contains.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkPolicyStatus","title":"NetworkPolicyStatus","text":"<p> (Appears on:NetworkPolicy) </p> <p>NetworkPolicyStatus defines the observed state of NetworkPolicy.</p> Field Description <code>conditions</code>  []NetworkPolicyCondition  <p>Conditions are various conditions of the NetworkPolicy.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkSpec","title":"NetworkSpec","text":"<p> (Appears on:Network) </p> <p>NetworkSpec defines the desired state of Network</p> Field Description <code>providerID</code>  string  <p>ProviderID is the provider-internal ID of the network.</p> <code>peerings</code>  []NetworkPeering  (Optional) <p>Peerings are the network peerings with this network.</p> <code>incomingPeerings</code>  []NetworkPeeringClaimRef  (Optional) <p>PeeringClaimRefs are the peering claim references of other networks.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkState","title":"NetworkState (<code>string</code> alias)","text":"<p> (Appears on:NetworkStatus) </p> <p>NetworkState is the state of a network.</p> Value Description <p>\"Available\"</p> <p>NetworkStateAvailable means the network is ready to use.</p> <p>\"Error\"</p> <p>NetworkStateError means the network is in an error state.</p> <p>\"Pending\"</p> <p>NetworkStatePending means the network is being provisioned.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.NetworkStatus","title":"NetworkStatus","text":"<p> (Appears on:Network) </p> <p>NetworkStatus defines the observed state of Network</p> Field Description <code>state</code>  NetworkState  <p>State is the state of the machine.</p> <code>peerings</code>  []NetworkPeeringStatus  (Optional) <p>Peerings contains the states of the network peerings for the network.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.PeeringPrefix","title":"PeeringPrefix","text":"<p> (Appears on:NetworkPeering) </p> <p>PeeringPrefixes defines prefixes to be exposed to the peered network</p> Field Description <code>name</code>  string  <p>Name is the semantical name of the peering prefixes</p> <code>prefix</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>CIDR to be exposed to the peered network</p> <code>prefixRef</code>  Kubernetes core/v1.LocalObjectReference  <p>PrefixRef is the reference to the prefix to be exposed to peered network An empty namespace indicates that the prefix resides in the same namespace as the source network.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.PeeringPrefixStatus","title":"PeeringPrefixStatus","text":"<p> (Appears on:NetworkPeeringStatus) </p> <p>PeeringPrefixStatus lists prefixes exposed to peered network</p> Field Description <code>name</code>  string  <p>Name is the name of the peering prefix</p> <code>prefix</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>CIDR exposed to the peered network</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.PolicyType","title":"PolicyType (<code>string</code> alias)","text":"<p> (Appears on:NetworkPolicySpec) </p> <p>PolicyType is a type of policy.</p> Value Description <p>\"Egress\"</p> <p>PolicyTypeEgress is a policy that describes egress traffic.</p> <p>\"Ingress\"</p> <p>PolicyTypeIngress is a policy that describes ingress traffic.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.PrefixSource","title":"PrefixSource","text":"<p> (Appears on:NetworkInterfaceSpec) </p> Field Description <code>value</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IPPrefix  <p>Value specifies a static prefix to use.</p> <code>ephemeral</code>  EphemeralPrefixSource  <p>Ephemeral specifies a prefix by creating an ephemeral ipam.Prefix to allocate the prefix with.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.ReclaimPolicyType","title":"ReclaimPolicyType (<code>string</code> alias)","text":"<p> (Appears on:EphemeralVirtualIPSpec) </p> <p>ReclaimPolicyType is the ironcore ReclaimPolicy of a VirtualIP.</p> Value Description <p>\"Delete\"</p> <p>ReclaimPolicyTypeDelete is used for any VirtualIP that is deleted when the claim of VirtualIP is released.</p> <p>\"Retain\"</p> <p>ReclaimPolicyTypeRetain is used for any VirtualIP that is retained when the claim of VirtualIP is released.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.VirtualIPSource","title":"VirtualIPSource","text":"<p> (Appears on:NetworkInterfaceSpec) </p> <p>VirtualIPSource is the definition of how to obtain a VirtualIP.</p> Field Description <code>virtualIPRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VirtualIPRef references a VirtualIP to use.</p> <code>ephemeral</code>  EphemeralVirtualIPSource  <p>Ephemeral instructs to create an ephemeral (i.e. coupled to the lifetime of the surrounding object) VirtualIP.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.VirtualIPSpec","title":"VirtualIPSpec","text":"<p> (Appears on:VirtualIP, EphemeralVirtualIPSpec) </p> <p>VirtualIPSpec defines the desired state of a VirtualIP</p> Field Description <code>type</code>  VirtualIPType  <p>Type is the type of VirtualIP.</p> <code>ipFamily</code>  Kubernetes core/v1.IPFamily  <p>IPFamily is the ip family of the VirtualIP.</p> <code>targetRef</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.LocalUIDReference  <p>TargetRef references the target for this VirtualIP (currently only NetworkInterface).</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.VirtualIPStatus","title":"VirtualIPStatus","text":"<p> (Appears on:VirtualIP) </p> <p>VirtualIPStatus defines the observed state of VirtualIP</p> Field Description <code>ip</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.IP  <p>IP is the allocated IP, if any.</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.VirtualIPTemplateSpec","title":"VirtualIPTemplateSpec","text":"<p> (Appears on:EphemeralVirtualIPSource) </p> <p>VirtualIPTemplateSpec is the specification of a VirtualIP template.</p> Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  EphemeralVirtualIPSpec  <code>VirtualIPSpec</code>  VirtualIPSpec  <p> (Members of <code>VirtualIPSpec</code> are embedded into this type.) </p> <p>VirtualIPSpec defines the desired state of a VirtualIP</p> <code>reclaimPolicy</code>  ReclaimPolicyType  <p>ReclaimPolicy is the ReclaimPolicyType of virtualIP</p>"},{"location":"api-reference/networking/#networking.ironcore.dev/v1alpha1.VirtualIPType","title":"VirtualIPType (<code>string</code> alias)","text":"<p> (Appears on:VirtualIPSpec) </p> <p>VirtualIPType is a type of VirtualIP.</p> Value Description <p>\"Public\"</p> <p>VirtualIPTypePublic is a VirtualIP that allocates and routes a stable public IP.</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"api-reference/overview/","title":"API Reference Documentation","text":"<p>This is the home of the API reference documentation grouped by the various API groups. The content in each subgroup is automatically generated from the Go types in the <code>apis</code> folder. For more information on how the documentation is built and how it can be updated please refer to the Updating API Reference Documentation in the documentation development guide.</p> <ul> <li>Core</li> <li>IPAM</li> <li>Compute</li> <li>Networking</li> <li>Storage</li> <li>Common</li> </ul>"},{"location":"api-reference/storage/","title":"Storage","text":"<p>Packages:</p> <ul> <li> storage.ironcore.dev/v1alpha1 </li> </ul>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1","title":"storage.ironcore.dev/v1alpha1","text":"<p>Package v1alpha1 is the v1alpha1 version of the API.</p> <p>Resource Types:</p> <ul><li> Bucket </li><li> BucketClass </li><li> BucketPool </li><li> Volume </li><li> VolumeClass </li><li> VolumePool </li><li> VolumeSnapshot </li></ul>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.Bucket","title":"Bucket","text":"<p>Bucket is the Schema for the buckets API</p> Field Description <code>apiVersion</code> string <code> storage.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>Bucket</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  BucketSpec  <code>bucketClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>BucketClassRef is the BucketClass of a bucket If empty, an external controller has to provision the bucket.</p> <code>bucketPoolSelector</code>  map[string]string  <p>BucketPoolSelector selects a suitable BucketPoolRef by the given labels.</p> <code>bucketPoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>BucketPoolRef indicates which BucketPool to use for a bucket. If unset, the scheduler will figure out a suitable BucketPoolRef.</p> <code>tolerations</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Bucket has. Only any BucketPool whose taints covered by Tolerations will be considered to host the Bucket.</p> <code>status</code>  BucketStatus"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.BucketClass","title":"BucketClass","text":"<p>BucketClass is the Schema for the bucketclasses API</p> Field Description <code>apiVersion</code> string <code> storage.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>BucketClass</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>capabilities</code>  github.com/ironcore-dev/ironcore/api/core/v1alpha1.ResourceList  <p>Capabilities describes the capabilities of a BucketClass.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.BucketPool","title":"BucketPool","text":"<p>BucketPool is the Schema for the bucketpools API</p> Field Description <code>apiVersion</code> string <code> storage.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>BucketPool</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  BucketPoolSpec  <code>providerID</code>  string  <p>ProviderID identifies the BucketPool on provider side.</p> <code>taints</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Taint  <p>Taints of the BucketPool. Only Buckets who tolerate all the taints will land in the BucketPool.</p> <code>status</code>  BucketPoolStatus"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.Volume","title":"Volume","text":"<p>Volume is the Schema for the volumes API</p> Field Description <code>apiVersion</code> string <code> storage.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>Volume</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  VolumeSpec  <code>volumeClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumeClassRef is the VolumeClass of a volume If empty, an external controller has to provision the volume.</p> <code>volumePoolSelector</code>  map[string]string  <p>VolumePoolSelector selects a suitable VolumePoolRef by the given labels.</p> <code>volumePoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumePoolRef indicates which VolumePool to use for a volume. If unset, the scheduler will figure out a suitable VolumePoolRef.</p> <code>claimRef</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.LocalUIDReference  <p>ClaimRef is the reference to the claiming entity of the Volume.</p> <code>resources</code>  github.com/ironcore-dev/ironcore/api/core/v1alpha1.ResourceList  <p>Resources is a description of the volume\u2019s resources and capacity.</p> <code>image</code>  string  <p>Image is an optional image to bootstrap the volume with. To be deprecated</p> <code>imagePullSecretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>ImagePullSecretRef is an optional secret for pulling the image of a volume.</p> <code>unclaimable</code>  bool  <p>Unclaimable marks the volume as unclaimable.</p> <code>tolerations</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Volume has. Only any VolumePool whose taints covered by Tolerations will be considered to host the Volume.</p> <code>encryption</code>  VolumeEncryption  <p>Encryption is an optional field which provides attributes to encrypt Volume.</p> <code>VolumeDataSource</code>  VolumeDataSource  <p> (Members of <code>VolumeDataSource</code> are embedded into this type.) </p> <p>VolumeDataSource is the source where the storage for the Volume resides at.</p> <code>status</code>  VolumeStatus"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeClass","title":"VolumeClass","text":"<p>VolumeClass is the Schema for the volumeclasses API</p> Field Description <code>apiVersion</code> string <code> storage.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>VolumeClass</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>capabilities</code>  github.com/ironcore-dev/ironcore/api/core/v1alpha1.ResourceList  <p>Capabilities describes the capabilities of a VolumeClass.</p> <code>resizePolicy</code>  ResizePolicy  <p>ResizePolicy describes the supported expansion policy of a VolumeClass. If not set default to Static expansion policy.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumePool","title":"VolumePool","text":"<p>VolumePool is the Schema for the volumepools API</p> Field Description <code>apiVersion</code> string <code> storage.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>VolumePool</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  VolumePoolSpec  <code>providerID</code>  string  <p>ProviderID identifies the VolumePool on provider side.</p> <code>taints</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Taint  <p>Taints of the VolumePool. Only Volumes who tolerate all the taints will land in the VolumePool.</p> <code>status</code>  VolumePoolStatus"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeSnapshot","title":"VolumeSnapshot","text":"<p>VolumeSnapshot is the Schema for the VolumeSnapshots API</p> Field Description <code>apiVersion</code> string <code> storage.ironcore.dev/v1alpha1 </code> <code>kind</code> string  <code>VolumeSnapshot</code> <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  VolumeSnapshotSpec  <code>volumeRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumeRef indicates which Volume to refer for VolumeSnapshot</p> <code>status</code>  VolumeSnapshotStatus"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.BucketAccess","title":"BucketAccess","text":"<p> (Appears on:BucketStatus) </p> <p>BucketAccess represents information on how to access a bucket.</p> Field Description <code>secretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>SecretRef references the Secret containing the access credentials to consume a Bucket.</p> <code>endpoint</code>  string  <p>Endpoint defines address of the Bucket REST-API.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.BucketCondition","title":"BucketCondition","text":"<p> (Appears on:BucketStatus) </p> <p>BucketCondition is one of the conditions of a bucket.</p> Field Description <code>type</code>  BucketConditionType  <p>Type is the type of the condition.</p> <code>status</code>  Kubernetes core/v1.ConditionStatus  <p>Status is the status of the condition.</p> <code>reason</code>  string  <p>Reason is a machine-readable indication of why the condition is in a certain state.</p> <code>message</code>  string  <p>Message is a human-readable explanation of why the condition has a certain reason / state.</p> <code>observedGeneration</code>  int64  <p>ObservedGeneration represents the .metadata.generation that the condition was set based upon.</p> <code>lastTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastTransitionTime is the last time the status of a condition has transitioned from one state to another.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.BucketConditionType","title":"BucketConditionType (<code>string</code> alias)","text":"<p> (Appears on:BucketCondition) </p> <p>BucketConditionType is a type a BucketCondition can have.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.BucketPoolSpec","title":"BucketPoolSpec","text":"<p> (Appears on:BucketPool) </p> <p>BucketPoolSpec defines the desired state of BucketPool</p> Field Description <code>providerID</code>  string  <p>ProviderID identifies the BucketPool on provider side.</p> <code>taints</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Taint  <p>Taints of the BucketPool. Only Buckets who tolerate all the taints will land in the BucketPool.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.BucketPoolState","title":"BucketPoolState (<code>string</code> alias)","text":"<p> (Appears on:BucketPoolStatus) </p> Value Description <p>\"Available\"</p> <p>\"Pending\"</p> <p>\"Unavailable\"</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.BucketPoolStatus","title":"BucketPoolStatus","text":"<p> (Appears on:BucketPool) </p> <p>BucketPoolStatus defines the observed state of BucketPool</p> Field Description <code>state</code>  BucketPoolState  <p>State represents the infrastructure state of a BucketPool.</p> <code>availableBucketClasses</code>  []Kubernetes core/v1.LocalObjectReference  <p>AvailableBucketClasses list the references of any supported BucketClass of this pool</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.BucketSpec","title":"BucketSpec","text":"<p> (Appears on:Bucket, BucketTemplateSpec) </p> <p>BucketSpec defines the desired state of Bucket</p> Field Description <code>bucketClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>BucketClassRef is the BucketClass of a bucket If empty, an external controller has to provision the bucket.</p> <code>bucketPoolSelector</code>  map[string]string  <p>BucketPoolSelector selects a suitable BucketPoolRef by the given labels.</p> <code>bucketPoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>BucketPoolRef indicates which BucketPool to use for a bucket. If unset, the scheduler will figure out a suitable BucketPoolRef.</p> <code>tolerations</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Bucket has. Only any BucketPool whose taints covered by Tolerations will be considered to host the Bucket.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.BucketState","title":"BucketState (<code>string</code> alias)","text":"<p> (Appears on:BucketStatus) </p> <p>BucketState represents the infrastructure state of a Bucket.</p> Value Description <p>\"Available\"</p> <p>BucketStateAvailable reports whether a Bucket is available to be used.</p> <p>\"Error\"</p> <p>BucketStateError reports that a Bucket is in an error state.</p> <p>\"Pending\"</p> <p>BucketStatePending reports whether a Bucket is about to be ready.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.BucketStatus","title":"BucketStatus","text":"<p> (Appears on:Bucket) </p> <p>BucketStatus defines the observed state of Bucket</p> Field Description <code>bucketID</code>  string  <p>BucketID is the provider-specific bucket ID in the format \u2018TYPE://BUCKET_ID\u2019.</p> <code>state</code>  BucketState  <p>State represents the infrastructure state of a Bucket.</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned between values.</p> <code>access</code>  BucketAccess  <p>Access specifies how to access a Bucket. This is set by the bucket provider when the bucket is provisioned.</p> <code>conditions</code>  []BucketCondition  <p>Conditions are the conditions of a bucket.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.BucketTemplateSpec","title":"BucketTemplateSpec","text":"<p>BucketTemplateSpec is the specification of a Bucket template.</p> Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  BucketSpec  <code>bucketClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>BucketClassRef is the BucketClass of a bucket If empty, an external controller has to provision the bucket.</p> <code>bucketPoolSelector</code>  map[string]string  <p>BucketPoolSelector selects a suitable BucketPoolRef by the given labels.</p> <code>bucketPoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>BucketPoolRef indicates which BucketPool to use for a bucket. If unset, the scheduler will figure out a suitable BucketPoolRef.</p> <code>tolerations</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Bucket has. Only any BucketPool whose taints covered by Tolerations will be considered to host the Bucket.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.ResizePolicy","title":"ResizePolicy (<code>string</code> alias)","text":"<p> (Appears on:VolumeClass) </p> <p>ResizePolicy is a type of policy.</p> Value Description <p>\"ExpandOnly\"</p> <p>ResizePolicyExpandOnly is a policy that only allows the expansion of a Volume.</p> <p>\"Static\"</p> <p>ResizePolicyStatic is a policy that does not allow the expansion of a Volume.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeAccess","title":"VolumeAccess","text":"<p> (Appears on:VolumeStatus) </p> <p>VolumeAccess represents information on how to access a volume.</p> Field Description <code>secretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>SecretRef references the Secret containing the access credentials to consume a Volume.</p> <code>driver</code>  string  <p>Driver is the name of the drive to use for this volume. Required.</p> <code>handle</code>  string  <p>Handle is the unique handle of the volume.</p> <code>volumeAttributes</code>  map[string]string  <p>VolumeAttributes are attributes of the volume to use.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeCondition","title":"VolumeCondition","text":"<p> (Appears on:VolumeStatus) </p> <p>VolumeCondition is one of the conditions of a volume.</p> Field Description <code>type</code>  VolumeConditionType  <p>Type is the type of the condition.</p> <code>status</code>  Kubernetes core/v1.ConditionStatus  <p>Status is the status of the condition.</p> <code>reason</code>  string  <p>Reason is a machine-readable indication of why the condition is in a certain state.</p> <code>message</code>  string  <p>Message is a human-readable explanation of why the condition has a certain reason / state.</p> <code>observedGeneration</code>  int64  <p>ObservedGeneration represents the .metadata.generation that the condition was set based upon.</p> <code>lastTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastTransitionTime is the last time the status of a condition has transitioned from one state to another.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeConditionType","title":"VolumeConditionType (<code>string</code> alias)","text":"<p> (Appears on:VolumeCondition) </p> <p>VolumeConditionType is a type a VolumeCondition can have.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeDataSource","title":"VolumeDataSource","text":"<p> (Appears on:VolumeSpec) </p> <p>VolumeDataSource specifies the source to use for a Volume.</p> Field Description <code>volumeSnapshotRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumeSnapshotRef instructs to use the specified VolumeSnapshot as the data source.</p> <code>osImage</code>  string  <p>OSImage is an optional os image to bootstrap the volume.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeEncryption","title":"VolumeEncryption","text":"<p> (Appears on:VolumeSpec) </p> <p>VolumeEncryption represents information to encrypt a volume.</p> Field Description <code>secretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>SecretRef references the Secret containing the encryption key to encrypt a Volume. This secret is created by user with encryptionKey as Key and base64 encoded 256-bit encryption key as Value.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumePoolCondition","title":"VolumePoolCondition","text":"<p> (Appears on:VolumePoolStatus) </p> <p>VolumePoolCondition is one of the conditions of a volume.</p> Field Description <code>type</code>  VolumePoolConditionType  <p>Type is the type of the condition.</p> <code>status</code>  Kubernetes core/v1.ConditionStatus  <p>Status is the status of the condition.</p> <code>reason</code>  string  <p>Reason is a machine-readable indication of why the condition is in a certain state.</p> <code>message</code>  string  <p>Message is a human-readable explanation of why the condition has a certain reason / state.</p> <code>observedGeneration</code>  int64  <p>ObservedGeneration represents the .metadata.generation that the condition was set based upon.</p> <code>lastTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastTransitionTime is the last time the status of a condition has transitioned from one state to another.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumePoolConditionType","title":"VolumePoolConditionType (<code>string</code> alias)","text":"<p> (Appears on:VolumePoolCondition) </p> <p>VolumePoolConditionType is a type a VolumePoolCondition can have.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumePoolSpec","title":"VolumePoolSpec","text":"<p> (Appears on:VolumePool) </p> <p>VolumePoolSpec defines the desired state of VolumePool</p> Field Description <code>providerID</code>  string  <p>ProviderID identifies the VolumePool on provider side.</p> <code>taints</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Taint  <p>Taints of the VolumePool. Only Volumes who tolerate all the taints will land in the VolumePool.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumePoolState","title":"VolumePoolState (<code>string</code> alias)","text":"<p> (Appears on:VolumePoolStatus) </p> Value Description <p>\"Available\"</p> <p>\"Pending\"</p> <p>\"Unavailable\"</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumePoolStatus","title":"VolumePoolStatus","text":"<p> (Appears on:VolumePool) </p> <p>VolumePoolStatus defines the observed state of VolumePool</p> Field Description <code>state</code>  VolumePoolState  <code>conditions</code>  []VolumePoolCondition  <code>availableVolumeClasses</code>  []Kubernetes core/v1.LocalObjectReference  <p>AvailableVolumeClasses list the references of any supported VolumeClass of this pool</p> <code>capacity</code>  github.com/ironcore-dev/ironcore/api/core/v1alpha1.ResourceList  <p>Capacity represents the total resources of a machine pool.</p> <code>allocatable</code>  github.com/ironcore-dev/ironcore/api/core/v1alpha1.ResourceList  <p>Allocatable represents the resources of a machine pool that are available for scheduling.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeSnapshotSpec","title":"VolumeSnapshotSpec","text":"<p> (Appears on:VolumeSnapshot) </p> <p>VolumeSnapshotSpec defines the desired state of VolumeSnapshot</p> Field Description <code>volumeRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumeRef indicates which Volume to refer for VolumeSnapshot</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeSnapshotState","title":"VolumeSnapshotState (<code>string</code> alias)","text":"<p> (Appears on:VolumeSnapshotStatus) </p> <p>VolumeSnapshotState is the state of a VolumeSnapshot</p> Value Description <p>\"Failed\"</p> <p>VolumeSnapshotStateFailed reports that a VolumeSnapshot is in failed state.</p> <p>\"Pending\"</p> <p>VolumeSnapshotStatePending reports whether a VolumeSnapshot is about to be ready.</p> <p>\"Ready\"</p> <p>VolumeSnapshotStateReady reports whether a VolumeSnapshot is ready to be used.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeSnapshotStatus","title":"VolumeSnapshotStatus","text":"<p> (Appears on:VolumeSnapshot) </p> <p>VolumeSnapshotStatus defines the observed state of VolumeSnapshot</p> Field Description <code>snapshotID</code>  string  <p>SnapshotID is the provider-specific snapshot ID in the format \u2018TYPE://SNAPSHOT_ID\u2019.</p> <code>state</code>  VolumeSnapshotState  <p>State represents the storage provider state of VolumeSnapshot</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned between values.</p> <code>size</code>  k8s.io/apimachinery/pkg/api/resource.Quantity  <p>Size is the storage size used by VolumeSnapshot</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeSpec","title":"VolumeSpec","text":"<p> (Appears on:Volume, VolumeTemplateSpec) </p> <p>VolumeSpec defines the desired state of Volume</p> Field Description <code>volumeClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumeClassRef is the VolumeClass of a volume If empty, an external controller has to provision the volume.</p> <code>volumePoolSelector</code>  map[string]string  <p>VolumePoolSelector selects a suitable VolumePoolRef by the given labels.</p> <code>volumePoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumePoolRef indicates which VolumePool to use for a volume. If unset, the scheduler will figure out a suitable VolumePoolRef.</p> <code>claimRef</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.LocalUIDReference  <p>ClaimRef is the reference to the claiming entity of the Volume.</p> <code>resources</code>  github.com/ironcore-dev/ironcore/api/core/v1alpha1.ResourceList  <p>Resources is a description of the volume\u2019s resources and capacity.</p> <code>image</code>  string  <p>Image is an optional image to bootstrap the volume with. To be deprecated</p> <code>imagePullSecretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>ImagePullSecretRef is an optional secret for pulling the image of a volume.</p> <code>unclaimable</code>  bool  <p>Unclaimable marks the volume as unclaimable.</p> <code>tolerations</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Volume has. Only any VolumePool whose taints covered by Tolerations will be considered to host the Volume.</p> <code>encryption</code>  VolumeEncryption  <p>Encryption is an optional field which provides attributes to encrypt Volume.</p> <code>VolumeDataSource</code>  VolumeDataSource  <p> (Members of <code>VolumeDataSource</code> are embedded into this type.) </p> <p>VolumeDataSource is the source where the storage for the Volume resides at.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeState","title":"VolumeState (<code>string</code> alias)","text":"<p> (Appears on:VolumeStatus) </p> <p>VolumeState represents the infrastructure state of a Volume.</p> Value Description <p>\"Available\"</p> <p>VolumeStateAvailable reports whether a Volume is available to be used.</p> <p>\"Error\"</p> <p>VolumeStateError reports that a Volume is in an error state.</p> <p>\"Pending\"</p> <p>VolumeStatePending reports whether a Volume is about to be ready.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeStatus","title":"VolumeStatus","text":"<p> (Appears on:Volume) </p> <p>VolumeStatus defines the observed state of Volume</p> Field Description <code>volumeID</code>  string  <p>VolumeID is the provider-specific volume ID in the format \u2018TYPE://VOLUME_ID\u2019.</p> <code>state</code>  VolumeState  <p>State represents the infrastructure state of a Volume.</p> <code>lastStateTransitionTime</code>  Kubernetes meta/v1.Time  <p>LastStateTransitionTime is the last time the State transitioned between values.</p> <code>access</code>  VolumeAccess  <p>Access specifies how to access a Volume. This is set by the volume provider when the volume is provisioned.</p> <code>conditions</code>  []VolumeCondition  <p>Conditions are the conditions of a volume.</p> <code>resources</code>  github.com/ironcore-dev/ironcore/api/core/v1alpha1.ResourceList  <p>Resources is a effective volume\u2019s resources.</p>"},{"location":"api-reference/storage/#storage.ironcore.dev/v1alpha1.VolumeTemplateSpec","title":"VolumeTemplateSpec","text":"<p>VolumeTemplateSpec is the specification of a Volume template.</p> Field Description <code>metadata</code>  Kubernetes meta/v1.ObjectMeta   Refer to the Kubernetes API documentation for the fields of the <code>metadata</code> field.  <code>spec</code>  VolumeSpec  <code>volumeClassRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumeClassRef is the VolumeClass of a volume If empty, an external controller has to provision the volume.</p> <code>volumePoolSelector</code>  map[string]string  <p>VolumePoolSelector selects a suitable VolumePoolRef by the given labels.</p> <code>volumePoolRef</code>  Kubernetes core/v1.LocalObjectReference  <p>VolumePoolRef indicates which VolumePool to use for a volume. If unset, the scheduler will figure out a suitable VolumePoolRef.</p> <code>claimRef</code>  github.com/ironcore-dev/ironcore/api/common/v1alpha1.LocalUIDReference  <p>ClaimRef is the reference to the claiming entity of the Volume.</p> <code>resources</code>  github.com/ironcore-dev/ironcore/api/core/v1alpha1.ResourceList  <p>Resources is a description of the volume\u2019s resources and capacity.</p> <code>image</code>  string  <p>Image is an optional image to bootstrap the volume with. To be deprecated</p> <code>imagePullSecretRef</code>  Kubernetes core/v1.LocalObjectReference  <p>ImagePullSecretRef is an optional secret for pulling the image of a volume.</p> <code>unclaimable</code>  bool  <p>Unclaimable marks the volume as unclaimable.</p> <code>tolerations</code>  []github.com/ironcore-dev/ironcore/api/common/v1alpha1.Toleration  <p>Tolerations define tolerations the Volume has. Only any VolumePool whose taints covered by Tolerations will be considered to host the Volume.</p> <code>encryption</code>  VolumeEncryption  <p>Encryption is an optional field which provides attributes to encrypt Volume.</p> <code>VolumeDataSource</code>  VolumeDataSource  <p> (Members of <code>VolumeDataSource</code> are embedded into this type.) </p> <p>VolumeDataSource is the source where the storage for the Volume resides at.</p> <p> Generated with <code>gen-crd-api-reference-docs</code> </p>"},{"location":"architecture/iri/","title":"IRI - IronCore Runtime Interface","text":""},{"location":"architecture/iri/#introduction","title":"Introduction","text":"<p>The IronCore Runtime Interface (IRI) is a GRPC-based abstraction layer introduced to ease the implementation of a <code>poollet</code> and <code>pool provider</code>. </p> <p>A <code>poollet</code> does not have any knowledge how the resources are materialized and where the <code>pool provider</code> runs. The responsibility of the <code>poollet</code> is to collect and resolve the needed dependencies to materialize a resource.</p> <p>A <code>pool provider</code> implements the IRI, where the IRI defines the correct creation and management of resources  handled by a <code>pool provider</code>. A <code>pool provider</code> of the IRI should follow the interface defined in the IRI APIs. </p> <pre><code>graph LR\n    P[poollet] --&gt; IRI\n    IRI{IRI} --&gt; B\n    B[pool provider]</code></pre>"},{"location":"architecture/iri/#pool-provider","title":"<code>pool provider</code>","text":"<p>A <code>pool provider</code> represents a specific implementation of resources managed by a Pool. The implementation details of the <code>pool provider</code> depend on the type of resource it handles, such as Compute or Storage resources.</p> <p>Based on the implementation of a <code>pool provider</code> it can serve multiple use-cases:  - to broker resources between different clusters e.g. volume-broker - to materialize resources e.g. block devices created in a Ceph cluster via the cephlet</p>"},{"location":"architecture/iri/#interface-methods","title":"Interface Methods","text":"<p>The IRI defines several interface methods categIRIzed into Compute, Storage, and Bucket.</p> <ul> <li>Compute Methods</li> <li>Storage Methods</li> <li>Bucket Methods</li> </ul> <p>The IRI definition can be extended in the future with new resource groups.</p>"},{"location":"architecture/iri/#diagram","title":"Diagram","text":"<p>Below is a diagram illustrating the relationship between <code>poollets</code>, IRI, and <code>pool providers</code> in the <code>ironcore</code> project.</p> <pre><code>graph TB\n    A[Machine] -- scheduled on --&gt; B[MachinePool]\n    C[Volume] -- scheduled on --&gt; D[VolumePool]\n    B -- announced by --&gt; E[machinepoollet]\n    D -- announced by --&gt; F[volumepoollet]\n    E -- GRPC calls --&gt; G[IRI compute provider]\n    F -- GRPC calls --&gt; H[IRI storage provider]\n    G -.sidecar to.- E\n    H -.sidecar to.- F</code></pre> <p>This diagram illustrates:</p> <ul> <li><code>Machine</code> resources are scheduled on a <code>MachinePool</code> which is announced by the <code>machinepoollet</code>.</li> <li>Similarly, <code>Volume</code> resources are scheduled on a <code>VolumePool</code> which is announced by the <code>volumepoollet</code>.</li> <li>The <code>machinepoollet</code> and <code>volumepoollet</code> each have an IRI <code>provider</code> sidecar, which provides a GRPC interface for  making calls to create, update, or delete resources.</li> <li>The IRI <code>provider</code> (Compute) is a sidecar to the <code>machinepoollet</code> and the IRI <code>provider</code> (Storage) is a sidecar to the  <code>volumepoollet</code>. They handle GRPC calls from their respective <code>poollets</code> and interact with the actual resources.</li> </ul>"},{"location":"architecture/overview/","title":"IronCore Architecture","text":""},{"location":"concepts/machine-exec-flow/","title":"Machine Exec","text":"<p>The <code>exec</code> feature allows accessing the serial console of a <code>compute.Machine</code> via the <code>ironcore-apiserver</code>. The following parties are involved in implementing <code>exec</code>:</p> <ul> <li><code>ironcore-apiserver</code></li> <li><code>machinepoollet</code></li> <li><code>iri-machine</code> implementor</li> </ul> <p>The connection flow between those components looks like the following:</p> <pre><code>sequenceDiagram\n    participant User as user\n    participant OA as ironcore-apiserver\n    participant MP as machinepoollet\n    participant OM as iri-machine implementor\n\n    User-&gt;&gt;OA: exec request with machine name\n    Note over OA: Get machine by name\n    Note over OA: Get machine pool\n    Note over OA: Find suitable address &amp; port\n    Note over OA: Create URL for exec request\n    OA-&gt;&gt;MP: HTTP request to exec URL\n    Note over MP: Check authentication &amp; authorization\n    MP-&gt;&gt;OM: Call Exec method\n    Note over OM: Provide functioning Exec implementation\n    Note over OM: iri-machine implementor generates unique token\n    Note over OM: Token-associated URL is called\n    Note over OM: Calls exec on its target\n    Note over OM: Proxies response from the ironcore-apiserver to the requester\n    OM--&gt;&gt;MP: Returns URL for exec session\n    MP--&gt;&gt;OA: Proxy response\n    OA--&gt;&gt;User: Proxy response</code></pre>"},{"location":"concepts/machine-exec-flow/#ironcore-apiserver","title":"<code>ironcore-apiserver</code>","text":"<p>The <code>ironcore-apiserver</code> implements <code>exec</code> as a custom subresource on the <code>Machine</code> resource. In the <code>ironcore</code> REST registry, it is registered as <code>machines/exec</code>.</p> <p>The subresource itself is implemented by implementing the <code>k8s.io/apiserver/pkg/registry/rest.Connecter</code> interface, which allows custom logic for handling <code>CONNECT</code> and their follow-up <code>GET</code> / <code>POST</code> requests.</p> <p>For <code>exec</code>, the <code>ironcore-apiserver</code> knows the name of the machine the user wants to access. It first gets the machine by its name (returning an error if it doesn't exist) and then the machine pool it's assigned to (also returning an error if the machine is not assigned to any pool or the machine pool does not exist).</p> <p>On the machine pool, it looks for a suitable address via the reported <code>MachinePool.Status.Addresses</code>, depending on the configurable preferred address types of the <code>ironcore-apiserver</code>. Once found, it uses the address together with the <code>MachinePool.Status.DaemonEndpoints.MachinepoolletEndpoint.Port</code> to create a URL to make the target <code>exec</code> request to. The URL is of the form</p> <pre><code>https://&lt;host&gt;:&lt;port&gt;/apis/compute.ironcore.dev/namespaces/&lt;namespace&gt;/machines/&lt;machine/exec\n</code></pre> <p>It then makes an http request to that location and proxies the resulting response to the original requester.</p>"},{"location":"concepts/machine-exec-flow/#machinepoollet","title":"<code>machinepoollet</code>","text":"<p>The <code>machinepoollet</code> provides the HTTP server wrapping the <code>iri-machine</code> implementor. This HTTP server also provides the aforementioned route to serve <code>exec</code> for a machine.</p> <p>When the <code>machinepoollet</code> gets a request to that URL it first checks whether the requesting entity is authenticated &amp; authorized to do an <code>exec</code> request for that machine. It does so by using a delegated authenticator / authorizer against the <code>kube-apiserver</code> the <code>ironcore-apiserver</code> is connected to.</p> <p>Once successfully authenticated &amp; authorized, the <code>machinepoollet</code> calls the <code>Exec</code> method of the <code>iri-machine</code> implementor. This <code>Exec</code> method returns a URL where the <code>exec</code> session for the target machine will be hosted at.</p> <p>It then makes an HTTP request to that URL and proxies the resulting response to the <code>ironcore-apiserver</code>.</p>"},{"location":"concepts/machine-exec-flow/#iri-machine-implementor","title":"<code>iri-machine</code> Implementor","text":"<p>The <code>iri-machine</code> implementor has to provide a functioning <code>Exec</code> implementation that returns the URL where the actual <code>exec</code> session of the machine is hosted at.</p> <p>For the <code>machinebroker</code>, this is implemented by having an HTTP server that associates the request together with a unique randomly generated token and returns a URL containing that token.</p> <p>Once the URL containing that token is called, the <code>machinebroker</code> looks up the corresponding request and calls <code>exec</code> on its target (different from the original) <code>ironcore-apiserver</code> with the machine namespace and name from the stored request. It then proxies the response from the <code>ironcore-apiserver</code> to the requester.</p>"},{"location":"development/contribution/","title":"Contributors Guide","text":""},{"location":"development/contribution/#contributing","title":"Contributing","text":"<p>The IronCore project uses Github to manage reviews of pull requests.</p> <ul> <li> <p>If you are looking to make your first contribution, follow Steps to Contribute</p> </li> <li> <p>If you have a trivial fix or improvement, go ahead and create a pull request and address (with @...) a suitable maintainer of this repository  (see CODEOWNERS  of this repository) in the description of the pull request.</p> </li> <li> <p>If you plan to do something more involved, first discuss your ideas by creating an  issue for this repository. This will avoid unnecessary work and surely give you  and us a good deal of inspiration.</p> </li> </ul> <p>Note</p> <p>Please follow these style guidelines to have your contribution considered by the maintainers: Coding style guidelines Go Code Review Comments, Formatting and style section of Peter Bourgon\u2019s Go: Best Practices for Production Environments.</p>"},{"location":"development/contribution/#steps-to-contribute","title":"Steps to Contribute","text":"<p>Do you want to work on an issue?  You are welcome to claim an existing one by commenting on it in GitHub. </p> <p>Note</p> <p>Perform a cursory search to see if the issue has already been taken by someone else.  This will prevent misunderstanding and duplication of  effort from contributors on the same issue.</p> <p>If you have questions about one of the issues please comment on them and one of the  maintainers will clarify it.</p> <p>We kindly ask you to follow the Pull Request Checklist to ensure reviews can happen accordingly.</p>"},{"location":"development/contribution/#contributing-code","title":"Contributing Code","text":"<p>You are welcome to contribute code to the IronCore project in order to fix a bug or to implement a new feature.</p> <p>The following rules govern code contributions:</p> <ul> <li>Contributions must be licensed under the Apache 2.0 License</li> <li>You need to sign the Developer Certificate of Origin.</li> </ul>"},{"location":"development/contribution/#contributing-documentation","title":"Contributing Documentation","text":"<p>You are welcome to contribute documentation to the IronCore project.</p> <p>The following rules govern documentation contributions:</p> <ul> <li>Contributions must be licensed under the Creative Commons Attribution 4.0 International License</li> <li>You need to sign the Developer Certificate of Origin.</li> </ul>"},{"location":"development/contribution/#developer-certificate-of-origin","title":"Developer Certificate of Origin","text":"<p>Due to legal reasons, contributors will be asked to accept a Developer Certificate of Origin (DCO) before they submit  the first pull request to the IronCore project, this happens in an automated fashion during the submission  process. We use the standard DCO text of the Linux Foundation.</p>"},{"location":"development/contribution/#pull-request-checklist","title":"Pull Request Checklist","text":"<ul> <li>Fork and clone the repository to you local machine.</li> </ul> <pre><code>git clone git@github.com:YOUR_GITHUB_USER/ironcore.git\ncd ironcore\n</code></pre> <ul> <li>Create a branch from the <code>main</code>  using 'git checkout' command. </li> </ul> <p>Note</p> <p>If needed, rebase to the current <code>main</code> branch before submitting  your pull request. If it doesn't merge properly with <code>main</code> you may be asked to rebase your changes.</p> <pre><code>git checkout -b my_feature\n# rebase if necessary\ngit fetch upstream main\ngit rebase upstream/main\n</code></pre> <ul> <li> <p>Commits should be as small as possible, while ensuring that each commit is correct independently  (i.e. each commit should compile and pass tests).</p> </li> <li> <p>Create your patch and test your changes  before you commit them. Automated test by unit / integration tests are preferred.  If tested manually, provide information about the test scope in the PR description. Now you can commit your changes to your feature branch and push it to your fork.</p> </li> </ul> <pre><code>git add .\ngit commit -m \"Something meaningful\"\ngit push origin my_feature\n</code></pre> <p>Note</p> <p>Alternatively you can amend your commit before pushing if you forgot something by using <code>git commit --amend</code></p> <ul> <li> <p>Create Work In Progress [WIP] pull requests only if you need a clarification or an explicit review before you can  continue your work item.</p> </li> <li> <p>If your patch is not getting reviewed, or you need a specific person to review it, you can @-reply a reviewer asking  for a review in the pull request or a comment.</p> </li> <li> <p>Post review:</p> <ul> <li>If a reviewer requires you to change your commit(s), please test the changes again.</li> <li>Amend the affected commit(s) and force push onto your branch.</li> <li>Set respective comments in your GitHub review as resolved.</li> <li>Create a general PR comment to notify the reviewers that your amendments are ready for another round of review.</li> </ul> </li> </ul>"},{"location":"development/contribution/#issues-and-planning","title":"Issues and Planning","text":"<p>We use GitHub issues to track bugs and enhancement requests. Please provide as much context as possible when you open  an issue. The information you provide must be comprehensive enough to understand, reproduce the behavior and find related reports of  that issue for the assignee.  Therefore, contributors may use but aren't restricted to the issue template provided by the IronCore maintainers.</p> <p>Issues and pull requests are tracked in the backlog for this project.</p>"},{"location":"development/documentation/","title":"Documentation Setup","text":"<p>The documentation of the ironcore project is written primarily using Markdown. All documentation related content can be found in the <code>/docs</code> folder. New content also should be added there. MkDocs and MkDocs Material are then used to render the contents of the <code>/docs</code> folder to have a more user-friendly experience when browsing the projects' documentation.</p> <p>Note</p> <p>One exception to the common contribution process builds the <code>docs/api-reference</code> folder. The folder contains auto-generated CRD reference documentation of the project, no manual contributions should be applied as they will be overwritten in the next generation step. To read more: Updating API Reference Documentation  section.</p>"},{"location":"development/documentation/#requirements","title":"Requirements:","text":"<p>Following tools are required to work on that package.</p> <ul> <li>Kubernetes cluster access to deploy and test the result (via minikube, kind or docker desktop locally)</li> <li>make - to execute build goals</li> <li>docker - to run the local mkdocs environment</li> <li>git - to be able to commit any changes to repository</li> <li>kubectl (&gt;= v1.23.4) - to be able to talk to the kubernetes cluster</li> </ul> <p>Note</p> <p>If you don't have Docker installed on your machine please follow one of those guides:</p> <ul> <li>Docker Desktop for Mac</li> <li>Docker Desktop for Windows</li> <li>Docker Engine for Linux</li> </ul>"},{"location":"development/documentation/#local-development-setup","title":"Local Development Setup","text":"<p>This project contains a local Docker based runtime environment for the documentation part. If you have an access to the docker registry and k8s installation that you can use for development purposes, just run following command and access the output in your browser under http://localhost:8000/:</p> <p><pre><code>make start-docs\n</code></pre> The environment will hot-rebuild your documentation, so there is no need to restart it while you make your changes. If you want to add a new chapter (basically a new file/folder to <code>docs</code> directory) you should add it to the <code>nav</code> section in the <code>mkdocs.yml</code> file in the projects root folder. Use helper Makefile directive to clean up old and stopped container instances.</p> <pre><code>make clean-docs\n</code></pre>"},{"location":"development/documentation/#writing-content","title":"Writing Content","text":""},{"location":"development/documentation/#api-reference-documentation","title":"API Reference Documentation","text":"<p>The API reference documentation contains auto-generated description from the CRD definition of the ironcore project. We are using the gen-crd-api-reference-docs project to generate the content. Under the hood we are using <code>go generate</code> instructions defined in each version type <code>doc.go</code>. The needed instructions to generate documentation for the <code>core/v1alpha1</code> types are in the example below:</p> <p><pre><code>//go:generate gen-crd-api-reference-docs -api-dir . -config ../../../hack/api-reference/core-config.json -template-dir ../../../hack/api-reference/template -out-file ../../../docs/api-reference/core.md\n</code></pre> Together with the comments in the corresponding type files <code>go generate</code> will call the <code>gen-crd-api-reference-doc</code> command to generate the output in the <code>/docs/api-reference</code> folder. The project contains a <code>Makefile</code> routine to generate the reference documentation for all types. In case you change any of the types in the <code>apis</code> folder just run:</p> <pre><code>make docs\n</code></pre> <p>Note</p> <p>The generated output should be part of your pull request.</p>"},{"location":"development/setup/","title":"Local Development Setup","text":""},{"location":"development/setup/#requirements","title":"Requirements","text":"<ul> <li><code>go</code> &gt;= 1.20</li> <li><code>git</code>, <code>make</code> and <code>kubectl</code></li> <li>Kustomize</li> <li>Access to a Kubernetes cluster (Minikube, kind or a   real cluster)</li> </ul>"},{"location":"development/setup/#clone-the-repository","title":"Clone the Repository","text":"<p>To bring up and start locally the <code>ironcore</code> project for development purposes you first need to clone the repository.</p> <pre><code>git clone git@github.com:ironcore-dev/ironcore.git\ncd ironcore\n</code></pre>"},{"location":"development/setup/#install-cert-manager","title":"Install cert-manager","text":"<p>If there is no cert-manager present in the cluster it needs to be installed.</p> <pre><code>kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.8.0/cert-manager.yaml\n</code></pre>"},{"location":"development/setup/#install-apis-into-the-cluster","title":"Install APIs into the Cluster","text":"<p>Your Kubernetes API server needs to know about the APIs which come with the <code>ironcore</code> project. To install the APIs your cluster, run</p> <pre><code>make install\n</code></pre> <p>Note: This requires the <code>APISERVER_IMG</code> (Makefile default set to <code>apiserver</code>) to be pullable from your kubernetes cluster. For local development with <code>kind</code>, a make target that builds and loads the api server image and then applies the manifests is available via</p> <pre><code>make kind-install\n</code></pre> <p>Note: In case that there are multiple environments running, ensure that <code>kind get clusters</code> is pointing to the default kind cluster.</p>"},{"location":"development/setup/#start-the-controller-manager","title":"Start the Controller Manager","text":"<p>The controller manager can be started via the following command</p> <pre><code>make run\n</code></pre>"},{"location":"development/setup/#apply-sample-manifests","title":"Apply Sample Manifests","text":"<p>The <code>config/samples</code> folder contains samples for all APIs supported by this project. You can apply any of the samples by running</p> <pre><code>kubectl apply -f config/samples/SOME_RESOURCE.yaml\n</code></pre>"},{"location":"development/setup/#rebuilding-api-type-and-manifests","title":"Rebuilding API Type and Manifests","text":"<p>Everytime a change has been done to any of the types definitions, the corresponding manifests and generated code pieces have to be rebuilt.</p> <pre><code>make generate\nmake manifests\n</code></pre> <p>Note: Make sure your APIs are up-to-date by running <code>make install</code> / <code>make kind-install</code> after your code / manifests have been regenerated.</p>"},{"location":"development/setup/#setup-formatting-tools","title":"Setup formatting tools","text":"<p>The project uses <code>gofmt</code> and <code>goimports</code> for formatting. <code>gofmt</code> is used with default settings. While <code>goimports</code> should be used with <code>--local github.com/ironcore-dev</code> flag, so that <code>goimports</code> would sort <code>ironcore</code> pkgs separately.</p> <p>You can automate running formatting tools in your IDE.</p> <ul> <li>VSCode -- add following to the <code>settings.json</code>:</li> </ul> <pre><code>    \"go.formatTool\": \"goimports\",\n    \"gopls\": {\n        \"formatting.local\": \"github.com/ironcore-dev\",\n    },\n</code></pre> <ul> <li>Goland -- go to <code>File -&gt; Settings -&gt; Tools -&gt; File Watchers</code> and replace contents of <code>Arguments</code>   with <code>--local github.com/ironcore -w $FilePath$</code></li> </ul>"},{"location":"development/setup/#cleanup","title":"Cleanup","text":"<p>To remove the APIs from your cluster, simply run</p> <pre><code>make uninstall\n</code></pre>"},{"location":"development/testing/","title":"Testing","text":"<p>This project is using Ginkgo as it's primary testing framework in conjunction with Gomega matcher/assertion library.</p>"},{"location":"development/testing/#unit-tests","title":"Unit Tests","text":"<p>Each package should consist of its own <code>suite_test</code> setup and the corresponding test cases for each component.</p> <p>Example of test suite setup is below:</p> <pre><code>package mypackage\n\nimport (\n    . \"github.com/onsi/ginkgo/v2\"\n    . \"github.com/onsi/gomega\"\n    \"testing\"\n)\n\nfunc Test(t *testing.T) {\n    RegisterFailHandler(ginkgo.Fail)\n    ginkgo.RunSpecs(t, \"MyComponent\")\n}\n</code></pre> <p>The testing code should meet the requirements of be common Ginkgo format</p> <pre><code>package mypackage\n\nimport\n...\n\nvar _ = Describe(\"MyComponent\", func() {\n\n    BeforeEach(func() {\n        // Code to run before each Context\n    })\n\n    Context(\"When doing x\", func() {\n        It(\"Should result in y\", func() {\n            By(\"Creating something in x\")\n            Expect(x.DoSomething()).To(Equal(\"expected result\"))\n        })\n    })\n})\n</code></pre> <p>Note</p> <p>here: Ginkgo documentation. Assertion examples can be found here: Gomega documentation.</p>"},{"location":"development/testing/#controller-tests","title":"Controller Tests","text":"<p>Setup a local Kubernetes control plane in order to write controller tests. Use <code>envtest</code> as a part of the controller-runtime project.</p> <p>Example of <code>suite_test.go</code> inside a controller package is below:</p> <pre><code>package my_controller_package\n\nimport\n...\n\n// Those global vars are needed later.\nvar cfg *rest.Config\nvar k8sClient client.Client\nvar testEnv *envtest.Environment\n\nfunc TestAPIs(t *testing.T) {\n    RegisterFailHandler(Fail)\n\n    RunSpecsWithDefaultAndCustomReporters(t,\n        \"Controller Suite\",\n        []Reporter{printer.NewlineReporter{}})\n}\n\nvar _ = BeforeSuite(func() {\n    ...\n    // Here is the actual envtest setup. Make sure that the path\n    // to your generated CRDs is correct, as it will be injected\n    // directly into the API server once the envtest environment comes up.\n    testEnv = &amp;envtest.Environment{\n        CRDDirectoryPaths:     []string{filepath.Join(\"..\", \"..\", \"..\", \"config\", \"crd\", \"bases\")},\n        ErrorIfCRDPathMissing: true,\n    }\n    ...\n    // Define scheme\n    err = api.AddToScheme(scheme.Scheme)\n    ...\n    // Create a corresponding Kubernetes client.\n    k8sClient, err = client.New(cfg, client.Options{Scheme: scheme.Scheme})\n    ...\n    k8sManager, err := manager.NewManager(cfg, ctrl.Options{\n        Scheme: scheme.Scheme,\n        // On MacOS it might happen, that the firewall warnings will\n        // popup if you open a port on your machine. It typically\n        // happens due to the metrics endpoint of the controller-manager.\n        // To prevent it, disable it in the local setup\n        // and set the Host parameter to localhost.\n        Host:               \"127.0.0.1\",\n        MetricsBindAddress: \"0\",\n    })\n    ...\n    // Register our reconciler with the manager. In case if you want to test\n    // multiple reconcilers at once you have to register them one by\n    // one in the same fashion as is shown below.\n    err = (&amp;MyObjectReconciler{\n        Client: k8sManager.GetClient(),\n        Scheme: k8sManager.GetScheme(),\n        Log:    ctrl.Log.WithName(\"controllers\").WithName(\"MyObject\"),\n    }).SetupWithManager(k8sManager)\n    ...\n\n    // Start the manager\n    go func() {\n        err = k8sManager.Manager.Start(ctrl.SetupSignalHandler())\n        Expect(err).ToNot(HaveOccurred())\n    }()\n\n}, 60)\n\nvar _ = AfterSuite(func() {\n    By(\"tearing down the test environment\")\n    err := testEnv.Stop()\n    Expect(err).NotTo(HaveOccurred())\n})\n</code></pre> <p>The Ginkgo style tests can be now written in the same manner as described in the Unit Test section. The only difference now is, that you have a working controller manager in the background which is reacting on changes in the Kubernetes API which you can access via the <code>k8sClient</code> to create or modify your resources.</p> <p>More information on the envtest setup you can find in the CRD testing section here: Kubebuilder</p>"},{"location":"development/testing/#running-tests","title":"Running Tests","text":"<p>Test run can be executed via:</p> <pre><code>make test\n</code></pre>"},{"location":"development/testing/#goland-integration","title":"Goland Integration","text":"<p>Running static Ginkgo/Gomega tests in Golang should work out of the box. However, in order to make the controller test run from within your IDE you need to expose the following environment variable inside your 'Test Run Configuration'</p> <pre><code>KUBEBUILDER_ASSETS=/PATH_TO_MY_WORKSPACE/ironcore-dev/ironcore/testbin/bin\n</code></pre> <p>This is typically the location of the Kubernetes control plane binaries on your machine.</p>"},{"location":"proposals/","title":"Proposals","text":"<p>This is the home of the <code>ironcore</code> enhancement/extension proposals. You can find the list of accepted proposals  in the poposal folder of our Github repository.</p>"},{"location":"proposals/#submitting-a-new-proposal","title":"Submitting a new proposal","text":"<p>Please use our proposal template to write and submit your proposal via a pull request. </p>"},{"location":"proposals/00-template/","title":"IEP-NNNN: Your short, descriptive title","text":""},{"location":"proposals/00-template/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/00-template/#summary","title":"Summary","text":""},{"location":"proposals/00-template/#motivation","title":"Motivation","text":""},{"location":"proposals/00-template/#goals","title":"Goals","text":""},{"location":"proposals/00-template/#non-goals","title":"Non-Goals","text":""},{"location":"proposals/00-template/#proposal","title":"Proposal","text":""},{"location":"proposals/00-template/#alternatives","title":"Alternatives","text":""},{"location":"proposals/01-networking-integration/","title":"01 networking integration","text":"<p>title: Networking Integration</p> <p>iep-number: 1</p> <p>creation-date: 2022-17-03</p> <p>status: implementable</p> <p>authors:</p> <ul> <li>\"@adracus\"</li> <li>\"@afritzler\"</li> </ul> <p>reviewers:</p> <ul> <li>\"@adracus\"</li> <li>\"@afritzler\"</li> <li>\"@MalteJ\"</li> <li>\"@guvenc\"</li> <li>\"@gehoern\"</li> </ul>"},{"location":"proposals/01-networking-integration/#iep-1-networking-integration","title":"IEP-1: Networking Integration","text":""},{"location":"proposals/01-networking-integration/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/01-networking-integration/#summary","title":"Summary","text":"<p>Networking is a crucial part in a modern cloud system: It enables systems to communicate within themselves and to the outside world. Orchestrating traffic, auditing it and gaining visibility of what is the desired state is key to a modern network architecture.</p> <p>Key of this IEP is to define the user-facing network API as well as its implications on any other type and the overall structure of <code>ironcore</code>.</p>"},{"location":"proposals/01-networking-integration/#motivation","title":"Motivation","text":"<p>Without networking, any machine / process running inside a datacenter cannot interact / affect the outside world. Networking is a crucial component that has to be implemented for ironcore to have business value. In a full-fledged state, networking also enables security to the outside world and within a datacenter itself.</p> <p>The basic use case we want to implement with ironcore is a machine that can access the internet and can be reached from the internet.</p>"},{"location":"proposals/01-networking-integration/#goals","title":"Goals","text":"<ul> <li>Define APIs for managing isolated networks. It should be possible to do conflict-free peering of networks in the   future.</li> <li>Define APIs for assigning / routing public IPs / prefixes to members of a network / subnet.</li> <li>Adapt the <code>compute.Machine</code> type to integrate with the network API.</li> <li>Have fully integrated IP address management for all resources (IPAM).</li> <li>It should be possible to extend the API in the future to achieve the following (listed by decreasing priority):<ul> <li>Regulate Communication within a subnet (plus security concepts)</li> <li>Subnet-to-subnet communication (plus security concepts)</li> <li>Isolated network-to-network communication (plus security concepts)</li> <li>Cross-region isolated network-to-network communication (plus security concepts)</li> </ul> </li> </ul>"},{"location":"proposals/01-networking-integration/#non-goals","title":"Non-Goals","text":"<ul> <li>Define Load Balancer APIs (L4 sooner in the future, L7 later)</li> <li>Implement any of the future API extensions listed above</li> <li>Allow a user to bring own public IP prefixes</li> <li>Feature-creep beyond a simplistic MVP</li> </ul>"},{"location":"proposals/01-networking-integration/#proposal","title":"Proposal","text":""},{"location":"proposals/01-networking-integration/#preface","title":"Preface","text":"<p>As ironcore is Kubernetes-API, it should integrate nicely within the existing ecosystem. Some API design choices are made in that regard. For further information about Kubernetes, see the Kubernetes reference .</p> <ul> <li>Kubernetes specifies multiple ip types using <code>IPFamily</code>. This means, that instead of e.g. an object having   <pre><code>ipv4: 10.0.0.1\nipv6: ffff::\n</code></pre>   Kubernetes specifies it as   <pre><code>ipFamilies: [IPv4, IPv6]\nips:\n- 10.0.0.1\n- ffff::\n</code></pre>   The proposal should integrate into Kubernetes by using the same notation.</li> <li>Resources that are created, managed, and deleted in scope of another resource are called <code>ephemeral</code>. An example in   Kubernetes is the <code>Pod.spec.volumes.ephemeralVolume</code> that creates a volume just before a   <code>Pod</code> is created and deletes it alongside the <code>Pod</code> after usage.</li> <li><code>1:1</code> binding between two resources is achieved by both resources referencing each other. This can be seen in   Kubernetes'   <code>PersistentVolumeClaim.Spec.volumeName</code> - <code>PersistentVolume.spec.claimRef</code>.</li> <li><code>1:n</code> binding between two resources is achieved by the resource on <code>n</code> side having a reference to the resource on   the <code>1</code> side. This can be seen in <code>n</code> <code>Pod.spec.nodeName</code> referencing a <code>Node</code>.</li> <li><code>m:n</code> binding between two resources is achieved by using <code>selector</code>s and a 'binding' resource that usually gets   created on-the-fly, though this also usually can be modified. An example can be seen in the relation between   <code>Service</code>s and <code>Pod</code>s. A <code>Service</code> selects multiple <code>Pod</code>s via its <code>.spec.selector</code>. The resulting manifested binding   resource is realized via the <code>Endpoints</code> kind that contains the current target list.</li> </ul> <p>The proposal is divided into two parts: The first part purely focuses on IP address management. The second part defines the actual networking types while allowing the user to use the IP address management features of the first part.</p>"},{"location":"proposals/01-networking-integration/#prefix-type","title":"<code>Prefix</code> type","text":"<p>The <code>Prefix</code> simplifies management of IP prefixes (v4 and v6 are both supported).</p> <p>An <code>Prefix</code> may be a root prefix by specifying no parent / parent selector and a prefix it manages. If an <code>Prefix</code> specifies a parent / parent selector, the requested prefix / prefix length is allocated from the parent (that matches, if selector is used). This means, prefixes can both be allocated dynamically by specifying only a desired prefix length or 'statically' by specifying the desired prefix.</p> <p>Example manifests:</p> <pre><code>apiVersion: ipam.ironcore.dev/v1alpha1\nkind: Prefix\nmetadata:\n  namespace: default\n  name: my-root-prefix\nspec:\n  prefix: 10.0.0.0/8\nstatus:\n  phase: Allocated\n---\napiVersion: ipam.ironcore.dev/v1alpha1\nkind: Prefix\nmetadata:\n  namespace: default\n  name: my-sub-prefix\nspec:\n  parentRef:\n    name: my-root-prefix\n#  parentSelector: # A metav1.LabelSelector can be used to select the parent.\n#    matchLabels:\n#      foo: bar\n  prefixLength: 16\n  # prefix: 10.0.0.0/16 # Once successfully allocated, the spec is patched.\nstatus:\n  phase: Pending # This will become `Allocated` once the controller approves it.\n</code></pre>"},{"location":"proposals/01-networking-integration/#network-type","title":"<code>Network</code> type","text":"<p>The namespaced <code>Network</code> type defines a <code>Network</code> bracket. Traffic from, to and within the <code>Network</code> can be managed. A <code>Network</code> has to specify the ip families it wants to allow (same is design as in the Kubernetes <code>Service</code> type).</p> <p>IP address space in a <code>Network</code> is not dictated in any way. A <code>Network</code> however has to accept any claimed IP address space within it. For initial design, a <code>Network</code> will only accept non-overlapping space. In a later version, this may be regulated with a field / policy of some kind.</p> <p>Example manifest:</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: Network\nmetadata:\n  namespace: default\n  name: my-network\n</code></pre>"},{"location":"proposals/01-networking-integration/#the-networkinterface-type","title":"The <code>NetworkInterface</code> type","text":"<p>A <code>NetworkInterface</code> is the binding piece between a <code>Machine</code> and a <code>Network</code>. A <code>NetworkInterface</code> references the <code>Network</code> it wants to join as well as the IPs it should use in that <code>Network</code>.</p> <p>The IPs (v4 / v6) can be specified in multiple ways:</p> <ul> <li>Without IPAM by specifying an IP literal</li> <li>As <code>ephemeral</code>, creating an <code>ipam.Prefix</code> with the prefix length of the specified ip family (32 / 128) that will be   owned and also deleted alongside the surrounding <code>NetworkInterface</code>. The name of the   created <code>ipam.Prefix</code> will be <code>&lt;nic-name&gt;-&lt;index&gt;</code>, where <code>&lt;index&gt;</code> is the index of the <code>ephemeral</code> in the <code>ips</code>   list. An existing <code>Prefix</code> with that name will not be used for the <code>NetworkInterface</code> to avoid using an unrelated   <code>Prefix</code> by mistake.</li> </ul> <p>When specifying IPs, a user should also specify <code>ipFamilies</code>. <code>ipFamilies</code> validates that there can be either a single <code>IPv4</code> / <code>IPv6</code>, or an ordered list of an <code>IPv4</code> / <code>IPv6</code> address. If left empty and it can be deducted deterministically from the <code>ips</code>, it will be defaulted. Same applies vice versa.</p> <p>The binding between a <code>NetworkInterface</code> and a <code>Machine</code> is bidirectional via <code>NetworkInterface.spec.machineRef.name</code> / <code>Machine.spec.networkInterfaces[*].name</code>. For the mvp, we will only allow exactly 1 <code>NetworkInterface</code> per <code>Machine</code> .</p> <p>Example usage:</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: NetworkInterface\nmetadata:\n  namespace: default\n  name: my-machine-interface\nspec:\n  networkRef:\n    name: my-network\n  ipFamilies: [IPv4, IPv6]\n  ips:\n#    - value: 10.0.0.1 # It is also possible to directly specify IPs without IPAM \n#    - value: 2607:f0d0:1002:51::4 # Same applies for v6 addresses\n    - ephemeral:\n        prefixTemplate:\n          spec:\n            prefixRef:\n              name: my-node-prefix-v4\n    - ephemeral:\n        prefixTemplate:\n          spec:\n            prefixRef:\n              name: my-node-prefix-v6\n  machineRef:\n    name: my-machine\nstatus:\n  ips: # This will be updated with the allocated addresses.\n    - 10.0.0.1\n    - 2607:f0d0:1002:51::4\n---\napiVersion: compute.ironcore.dev/v1alpha1\nkind: Machine\nmetadata:\n  namespace: default\n  name: my-machine\n  labels:\n    app: web\nspec:\n  networkInterfaces:\n    - name: my-interface\n      networkInterfaceRef:\n        name: my-machine-interface\n  ...\nstatus:\n  networkInterfaces:\n    - name: my-interface\n      ips: # The machine reports all ips available via its interfaces\n        - 10.0.0.1\n        - 2607:f0d0:1002:51::4\n  ...\n</code></pre> <p>To simplify managing the creation of a <code>NetworkInterface</code> per <code>Machine</code>, a <code>Machine</code> can specify a <code>NetworkInterface</code> as <code>ephemeral</code>, creating and owning it before the <code>Machine</code> becomes available. The name of the <code>NetworkInterface</code> will be <code>&lt;machine-name&gt;-&lt;name&gt;</code> where <code>&lt;name&gt;</code> is the <code>name:</code> value in the <code>networkInterfaces</code> list. Existing <code>NetworkInterface</code>s will not be adopted by the <code>Machine</code>.</p> <p>Sample manifest:</p> <pre><code>apiVersion: compute.ironcore.dev/v1alpha1\nkind: Machine\nspec:\n  interfaces:\n    - name: my-interface\n      ephemeral:\n        networkInterfaceTemplate:\n          spec:\n            ipFamilies: [IPv4, IPv6]\n            networkRef:\n              name: my-network\n            ips:\n              - ephemeral:\n                  prefixTemplate:\n                    spec:\n                      prefixRef:\n                        name: my-node-prefix-v4\n              - ephemeral:\n                  prefixTemplate:\n                    spec:\n                      prefixRef:\n                        name: my-node-prefix-v6\n  ...\n</code></pre>"},{"location":"proposals/01-networking-integration/#the-aliasprefix-type","title":"The <code>AliasPrefix</code> type.","text":"<p>An <code>AliasPrefix</code> allows routing a sub-prefix of a network to multiple targets (in our case, <code>NetworkInterface</code>s). It references its target <code>Network</code> and selects the <code>NetworkInterfaces</code> via its <code>selector</code> to apply the alias to.</p> <p>The <code>AliasPrefix</code> creates an <code>AliasPrefixRouting</code> object with the same name as itself where it maintains a list of the <code>NetworkInterface</code>s matching its <code>selector</code>. If the <code>selector</code> is empty it is assumed that an external process manages the <code>AliasPrefixRouting</code> belonging to that <code>AliasPrefix</code>.</p> <p>Example manifest:</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: AliasPrefix\nmetadata:\n  namespace: default\n  name: my-pod-prefix-1\nspec:\n  ipFamily: IPv4\n  networkRef:\n    name: my-network\n  networkInterfaceSelector:\n    matchLabels:\n      foo: bar\n  prefix:\n#    value: 10.0.0.0/24 # It's possible to directly specify the AliasPrefix value\n    ephemeral:\n      prefixTemplate:\n        spec:\n          prefixRef:\n            name: my-pod-prefix\n          prefixLength: 24\nstatus:\n  prefix: 10.0.0.0/24\n</code></pre> <p>This could manifest in the following <code>AliasPrefixRouting</code>:</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: AliasPrefixRouting\nmetadata:\n  namespace: default\n  name: my-pod-prefix-1\nnetworkRef:\n  name: my-network\ndestinations:\n  - name: my-machine-interface-1\n    uid: 2020dcf9-e030-427e-b0fc-4fec2016e73a\n  - name: my-machine-interface-2\n    uid: 2020dcf9-e030-427e-b0fc-4fec2016e73d\n</code></pre> <p>To simplify the creation and use of an <code>AliasPrefix</code> per <code>NetworkInterface</code>, a <code>NetworkInterface</code> allows the creation via <code>ephemeralAliasPrefixes</code>. The resulting <code>AliasPrefix</code> name will be <code>&lt;nic-name&gt;-&lt;name&gt;</code> where <code>&lt;name&gt;</code> is the name in the <code>ephemeralAliasPrefixes</code> list.</p> <p>It will also automatically be set in the same network and only target the hosting <code>NetworkInterface</code>. <code>selector</code> and <code>networkRef</code> in <code>spec</code> thus cannot be specified.</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: NetworkInterface\nmetadata:\n  namespace: default\n  name: my-machine-interface\nspec:\n  ephemeralAliasPrefixes:\n    - name: podrange-v4\n      spec:\n        prefix:\n#          value: 10.0.0.0/24 # It's possible to directly specify the AliasPrefix value\n          ephemeralPrefix:\n            spec:\n              prefixRef:\n                name: my-pod-prefix\n              prefixLength: 24\n</code></pre>"},{"location":"proposals/01-networking-integration/#the-virtualip-type","title":"The <code>VirtualIP</code> type","text":"<p>A <code>VirtualIP</code> requests a stable public IP for a single targets (<code>NetworkInterface</code>s). There is a <code>type</code> field that currently only can be <code>type: Public</code> in order to support other future <code>VirtualIP</code> types (for instance, <code>VirtualIP</code>s in other networks).</p> <p>As the public prefixes are provider-managed and custom public IP pools are not in scope of this draft, the IP allocation cannot be influenced and thus no construct like <code>prefixRef</code> is possible for <code>VirtualIP</code>s.</p> <p>To disambiguate between IPv4 and IPv6, the <code>VirtualIP</code> requires an <code>ipFamily</code> (same enum type as in Kubernetes' <code>Service.spec.ipFamilies</code>).</p> <p>The <code>VirtualIP</code> references the claiming <code>NetworkInterface</code> using <code>targetRef</code>.</p> <p>Example manifest:</p> <pre><code>apiVersion: networking.ironcore.dev\nkind: VirtualIP\nmetadata:\n  namespace: default\n  name: my-virtual-ip\nspec:\n  type: Public\n  ipFamily: IPv4\n  targetRef:\n    name: my-nic\n    uid: 2020dcf9-e030-427e-b0fc-4fec2016e73d\nstatus:\n  ip: 45.86.152.88\n  phase: Bound\n</code></pre> <p>To simplify the creation and use of a <code>VirtualIP</code> per <code>NetworkInterface</code>, a <code>NetworkInterface</code> allows the creation via <code>virtualIP.ephemeral</code>. The resulting <code>VirtualPrefix</code> name will be <code>&lt;nic-name&gt;</code> It will also automatically be set up to reference the creating <code>NetworkInterface</code>. A <code>networkInterfaceRef</code> in the <code>spec</code> thus cannot be specified.</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: NetworkInterface\nmetadata:\n  namespace: default\n  name: my-machine-interface\nspec:\n  virtualIP:\n    ephemeral:\n      virtualIPTemplate:\n        spec:\n          type: Public\n          ipFamily: IPv4\n</code></pre>"},{"location":"proposals/01-networking-integration/#scenarios","title":"Scenarios","text":""},{"location":"proposals/01-networking-integration/#kubernetes-gardener-integration-on-top-of-ironcore","title":"Kubernetes (Gardener) integration on top of ironcore","text":"<p>For a Kubernetes integration, multiple worker nodes should be created in the same network. For each worker node, a separate pod prefix should be allocated. For internet-facing requests, each node should get a distinct public <code>VirtualIP</code> (in the future, outgoing requests will be solved via <code>SNAT</code>, but for the initial version of the MVP a <code>VirtualIP</code> is chosen).</p> <p>Additionally, to show it's possible, an <code>AliasPrefix</code> that is shared across different nodes is created.</p> <p>These are the required manifests:</p> <pre><code># IPAM Setup:\n# Create a root prefix and a pod / node sub-prefix.\napiVersion: ipam.ironcore.dev/v1alpha1\nkind: Prefix\nmetadata:\n  namespace: default\n  name: root\nspec:\n  prefix: 10.0.0.0/8\n---\napiVersion: ipam.ironcore.dev/v1alpha1\nkind: Prefix\nmetadata:\n  namespace: default\n  name: pods\nspec:\n  prefixLength: 11\n  parentRef:\n    name: root\n---\napiVersion: ipam.ironcore.dev/v1alpha1\nkind: Prefix\nmetadata:\n  namespace: default\n  name: nodes\nspec:\n  prefixLength: 16\n  parentRef:\n    name: root\n---\n# Once IPAM is done, the concrete networking is defined\n# The Network is the bracket around all resources\napiVersion: networking.ironcore.dev/v1alpha1\nkind: Network\nmetadata:\n  namespace: default\n  name: k8s\n---\n# Create one prefix that should be shared across all machines\napiVersion: networking.ironcore.dev/v1alpha1\nkind: AliasPrefix\nmetadata:\n  namespace: default\n  name: shared\nspec:\n  networkRef:\n    name: k8s\n  networkInterfaceSelector:\n    matchLabels:\n      type: k8s-worker\n  prefix:\n    ephemeral:\n      prefixTemplate:\n        spec:\n          prefixRef:\n            name: k8s\n          prefixLength: 16\n---\n# Create the actual machine\napiVersion: compute.ironcore.dev/v1alpha1\nkind: Machine\nmetadata:\n  namespace: default\n  name: worker-1\n  labels:\n    type: k8s-worker\nspec:\n  image: gardenlinux-k8s-worker:v0.23.5\n  networkInterfaces:\n    - name: primary\n      ephemeral:\n        networkInterfaceTemplate:\n          spec:\n            # Let the nic join the network\n            networkRef:\n              name: k8s\n            # The IP should be allocated from the node range\n            ips:\n              - ephemeral:\n                  prefixTemplate:\n                    spec:\n                      ipFamily: IPv4\n                      prefixRef:\n                        name: nodes\n            # Create a pod alias range exclusively for this machine\n            ephemeralAliasPrefixes:\n              - name: pods\n                spec:\n                  prefix:\n                    ephemeral:\n                      prefixTemplate:\n                        ipFamily: IPv4\n                        spec:\n                          prefixRef:\n                            name: pods\n                          prefixLength: 24\n            # Create a virtual IP for this machine\n            virtualIP:\n              - ephemeral:\n                  virtualIPTemplate:\n                    spec:\n                      type: Public\n                      ipFamily: IPv4\n</code></pre>"},{"location":"proposals/01-networking-integration/#alternatives","title":"Alternatives","text":"<p>None discussed so far.</p>"},{"location":"proposals/02-machine-console-access/","title":"IEP-02: Machine Console Access","text":""},{"location":"proposals/02-machine-console-access/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/02-machine-console-access/#summary","title":"Summary","text":"<p>A user of the ironcoreshould be able to access the serial console of their machine to access / debug / run imperative commands on it. For this, an endpoint + client-side tooling has to be created as well as the server-side machinery.</p>"},{"location":"proposals/02-machine-console-access/#motivation","title":"Motivation","text":"<p>Users should be able to access / debug / run imperative commands on their machines. This gives immediate feedback on the state of the machine and is a required feature for our minimum viable product.</p>"},{"location":"proposals/02-machine-console-access/#goals","title":"Goals","text":"<ul> <li>Define an endpoint + client side tooling for machine console access</li> <li>Define a server-side interface machine pool providers have to implement in order to   support console access to their machines.</li> </ul>"},{"location":"proposals/02-machine-console-access/#non-goals","title":"Non-Goals","text":"<ul> <li>Due to the imperative nature of consoles, no declarative interface to consoles should be defined.</li> <li>Have consoles as a building piece of other parts of the ironcore.</li> </ul>"},{"location":"proposals/02-machine-console-access/#proposal","title":"Proposal","text":""},{"location":"proposals/02-machine-console-access/#user-facing-api","title":"User-facing API","text":"<p>The <code>compute.ironcore.dev/Machine</code> resource is extended with an <code>exec</code> subresource. When connecting to that subresource, a websocket connection to the backing machine console should be opened. Supported HTTP methods for the <code>exec</code> call are <code>POST</code> and <code>GET</code> (in order to be able to do this from a browser as well).</p> <p>Example call to the Kubernetes API server hosting the aggregated API:</p> <p>```http request GET https:///apis/compute.ironcore.dev/v1alpha1/namespaces//machines//exec <pre><code>### Server-Side API\n\nOnce the server receives such a request, it gets the `Machine` and looks up the `MachinePool` the `Machine`\nis running on. If the `Machine` does not exist or is not scheduled onto a `MachinePool`, an error is returned.\n\nAfter identifying the responsible `MachinePool`, it is retrieved and its `.status.addresses` field is inspected\nfor an address to call. The `.status.addresses` field does not exist yet and has to be updated in the ironcore.\nIt is the responsibility of the `MachinePool` implementor to report its endpoints in the `status`.\n\nFor reference on the address type, see\n[the Kubernetes node address type](https://kubernetes.io/docs/reference/generated/kubernetes-api/v1.23/#nodeaddress-v1-core)\nwhich will be used as reference for designing the address type.\n\nExample manifest:\n\n```yaml\napiVersion: compute.ironcore.dev/v1alpha1\nkind: MachinePool\nmetadata:\n  name: my-machine-pool\nspec:\n  providerID: my://machine-pool\nstatus:\n  addresses:\n    - address: 10.250.0.38\n      type: InternalIP\n    - address: my-machine-pool-host\n      type: ExternalDNS\n</code></pre> <p>Once an address has been identified, the ironcore API server calls the endpoint of the <code>MachinePool</code> provider with an <code>exec</code> request for the <code>Machine</code>. The resulting websocket connection is proxied through the ironcore API server to the user.</p> <p><code>http request GET https://&lt;machine-pool-adddress&gt;/apis/compute.ironcore.dev/namespaces/&lt;namespace&gt;/machines/&lt;machine&gt;/exec</code></p> <p>Caution: This proposal does not include anything on authentication mechanisms yet. Implementors can already implement the endpoint but authentication will be added in the future.</p>"},{"location":"proposals/02-machine-console-access/#alternatives","title":"Alternatives","text":""},{"location":"proposals/03-loadbalancer/","title":"IEP-3: Network Loadbalancer","text":""},{"location":"proposals/03-loadbalancer/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> <li>Details</li> </ul> </li> <li>Proposal</li> </ul>"},{"location":"proposals/03-loadbalancer/#summary","title":"Summary","text":"<p>Load Balancing is an essential requirement in any modern network architecture. It makes backend services scalable, fault-tolerant and provides easy-to-consume access to external consumers.</p> <p>There are multiple types and strategies for load balancing: IP-based load balancing (L3 in the OSI model), Port-based load balancing (L4) and application-based load balancing (L7). This proposal focuses on IP-based load balancers, since they can be used as a foundation for the higher level load balancer types.</p>"},{"location":"proposals/03-loadbalancer/#motivation","title":"Motivation","text":"<p>A <code>VirtualIP</code> (IEP-1) allows to expose a <code>NetworkInterface</code> with a stable public IP. Services running on a <code>Machine</code> using that <code>NetworkInterface</code> can be consumed this way. However, if the <code>Machine</code> or the service running on that <code>Machine</code> crashes, the service will have an outage. To be more resilient and to scale beyond single <code>NetworkInterface</code>s, a <code>LoadBalancer</code> allows targeting multiple <code>NetworkInterface</code>s and distributes traffic between them.</p>"},{"location":"proposals/03-loadbalancer/#goals","title":"Goals","text":"<ul> <li>Define an API for managing L3 load balancers with publicly available addresses</li> <li>Load balancers should allow specifying their IP stack (<code>IPv4</code> / <code>IPv6</code> / dual stack). Public IP addresses   should be allocated according to the specified IP stack.</li> <li>Load balancers should support multiple target <code>NetworkInterface</code>s (   see (IEP-1)</li> <li>The load balancer should dynamically watch for target <code>NetworkInterface</code>s.</li> <li>All target <code>NetworkInterface</code>s must be in the same <code>Network</code>.</li> <li>The load balancer should be able to filter unwanted traffic. The filtering must not alter the packages.   The following filters should be implemented:<ul> <li>Filter depending on ports &amp; protocols (UDP/TCP/SCTP).</li> <li>ICMP requests should be filtered out by default.</li> </ul> </li> <li>Load balancing must be transparent for both target and source.</li> </ul>"},{"location":"proposals/03-loadbalancer/#non-goals","title":"Non-Goals","text":"<ul> <li>No address or port translation / rewriting (no SNAT / DNAT) (L4 Loadbalancer) support</li> <li>No injection of additional information (e.g. x-forwarded-for) (L7 Loadbalancer) support</li> <li>No protocol offloading like ssl (L7 Loadbalancer) support</li> <li>If more load balancer IPs are required than a single load balancer serves, more load balancers have to be requested.</li> </ul>"},{"location":"proposals/03-loadbalancer/#details","title":"Details","text":"<ul> <li>Load balancing is used to deliver a packet addressed to the load balancer to one of its targets via the ironcore   network routing</li> <li>The target needs to be aware of the load balancer's IP and needs to answer with it (and to receive traffic with it)</li> <li>Answers to the request will be directly delivered since all details are known by the target</li> </ul>"},{"location":"proposals/03-loadbalancer/#proposal","title":"Proposal","text":"<p>Introduce a <code>LoadBalancer</code> resource that dynamically selects multiple target <code>NetworkInterface</code>s via a <code>networkInterfaceSelector</code> <code>metav1.LabelSelector</code> (as e.g. in <code>AliasPrefix</code>es). The <code>LoadBalancer</code> of <code>type: Public</code> should allocate public IPs for its <code>ipFamilies</code> and announce them in its <code>status.ips</code>. <code>ports</code> defines an allow list of which traffic should be handled by a <code>LoadBalancer</code>. A <code>port</code> consists of a <code>protocol</code>, <code>port</code> and an optional <code>portEnd</code> to support port range filtering. <code>networkRef</code> defines the target <code>Network</code> a <code>NetworkInterface</code> has to be in in order to be an eligible target for traffic forwarding (see IEP-1).</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: LoadBalancer\nmetadata:\n  namespace: default\n  name: my-load-balancer\nspec:\n  # type denotes which kind of load balancer to create. For now, only `Public` is supported.\n  type: Public\n  # ip families specifies the supported IP stack of a load balancer. May be `IPv4`, `IPv6` or both (dual stack).\n  ipFamilies: [ IPv4, IPv6 ]\n  # ports is an allow list of traffic to load balance via port(range) and protocol.\n  ports:\n    - # protocols supported UDP, TCP, SCTP\n      protocol: tcp\n      # single port\n      port: 80\n    - protocol: udp\n      # port range\n      port: 1024\n      portEnd: 2048\n  # networkRef specifies the target network any target network interface should be in.\n  networkRef:\n    name: my-network\n  # network interface selector specifies the network interfaces to select for load balancing.\n  networkInterfaceSelector:\n    matchLabels:\n      key: db\n      foo: bar\nstatus:\n  # ips are the ips allocated for the load balancer.\n  ips:\n    - 45.86.152.88\n    - 2001::\n</code></pre>"},{"location":"proposals/03-loadbalancer/#routing-state-object","title":"Routing State Object","text":"<p>The load balancer needs details computable at the ironcore API level to describe the explicit targets in a pool traffic is routed to. <code>LoadBalancerRouting</code> describes <code>NetworkInterface</code>s load balanced traffic is routed to. This object describes a state of the <code>LoadBalancer</code> and results of the <code>LoadBalancer</code> definition specifically <code>networkInterfaceSelector</code> and <code>networkRef</code>. <code>LoadBalancerRouting</code> is reconciled by the <code>ironcore</code> load balancer controller.</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: LoadBalancerRouting\nmetadata:\n  namespace: default\n  name: my-load-balancer # Same name as the load balancer it originates from.\n# networkRef references the exact network object the routing belongs to.\nnetworkRef:\n  name: my-network\n# destinations lists the target network interface instances (including UID) for load balancing.\ndestinations:\n  - name: my-machine-interface-1\n    uid: 2020dcf9-e030-427e-b0fc-4fec2016e73a\n  - name: my-machine-interface-2\n    uid: 2020dcf9-e030-427e-b0fc-4fec2016e73d\n</code></pre>"},{"location":"proposals/04-nat-gateway/","title":"04 nat gateway","text":"<p>title: NAT Gateway</p> <p>iep-number: 4</p> <p>creation-date: 2022-18-10</p> <p>status: implementable</p> <p>authors:</p> <ul> <li>\"@gehoern\"</li> <li>\"@adracus\"</li> </ul> <p>reviewers:</p> <ul> <li>\"@MalteJ\"</li> <li>\"@adracus\"</li> <li>\"@afritzler\"</li> <li>\"@guvenc\"</li> </ul>"},{"location":"proposals/04-nat-gateway/#iep-4-cloud-nate-gateway","title":"IEP-4: Cloud Nate Gateway","text":""},{"location":"proposals/04-nat-gateway/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> </ul>"},{"location":"proposals/04-nat-gateway/#summary","title":"Summary","text":"<p>NAT gateways are essential for safe and resource-efficient internet access. Any machine (even those with no public / virtual IP) using a NAT gateway can access the internet without being directly exposed. IPs belonging to the NAT gateway are shared between multiple clients. Communication initiated by a member can get answers from outside (connection tracking) but the member cannot be contacted (no remote initiated traffic) from outside.</p>"},{"location":"proposals/04-nat-gateway/#motivation","title":"Motivation","text":"<p>A <code>NetworkInterface</code>s may have no dedicated public IP addresses (no <code>VirtualIP</code> via <code>spec.virtualIP</code>) but still may need public internet access. A NAT gateway provides this functionality by defining a default gateway to the network interface and a NAT for incoming and outgoing traffic (e.g. downloading container images). The <code>NetworkInterface</code> thus can reach the public internet but is not exposed as it would be when using a <code>VirtualIP</code>.</p>"},{"location":"proposals/04-nat-gateway/#goals","title":"Goals","text":"<ul> <li>A public NAT gateway should only target a single <code>Network</code>.</li> <li>Define an API for managing NAT gateways with publicly available addresses.</li> <li>Define the maximum ports of a NAT gateway to be used by a target <code>NetworkInterface</code>.</li> <li>Define the name of the <code>Network</code> and the <code>NetworkInterface</code> the NAT gateway is operating on.</li> </ul>"},{"location":"proposals/04-nat-gateway/#non-goals","title":"Non-Goals","text":"<ul> <li>The NAT gateway is not transparent since it manipulates the source port for outgoing traffic towards the remote   target.</li> </ul>"},{"location":"proposals/04-nat-gateway/#proposal","title":"Proposal","text":"<p>Introduce a <code>NATGateway</code> resource that targets <code>NetworkInterface</code>s in a <code>Network</code>. The <code>Network</code> is specified via a <code>networkRef</code>, the <code>NetworkInterface</code>s are targeted via a <code>LabelSelector</code>. During reconciliation, only <code>NetworkInterface</code>s that are not yet exposed via <code>VirtualIP</code> are selected and will be NATed and get masqueraded internet access. To denote a <code>NATGateway</code> as publicly facing, <code>type: Public</code> must be specified. For now, this is the only supported type. A <code>NATGateway</code> must specify the IP stack it operates on via <code>ipFamilies</code>. This can be <code>IPv4</code>, <code>IPv6</code> or both ( dual-stack). The <code>ips</code> field names the ips allocated for a <code>NATGateway</code>. If <code>ipFamilies</code> is dual-stack, both an <code>IPv4</code> and <code>IPv6</code> ip address will be allocated for each item in the <code>ips</code> field. The field <code>portsPerNetworkInterface</code> defines the maximum number of concurrent connections from a single <code>NetworkInterface</code> to a remote IP. The current usage of ports is reported in <code>status.portsUsed</code>.</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: NATGateway\nmetadata:\n  namespace: default\n  name: my-nat\nspec:\n  # Type denotes the type of nat gateway. For now, only 'Public' is supported.k:w\n  type: Public\n  # ip families specifies the supported IP stack of a load balancer. May be `IPv4`, `IPv6` or both (dual stack).\n  ipFamilies: [ IPv4, IPv6 ]\n  # the network the nat gateway targets.\n  networkRef:\n    name: sample-network\n  # ips are the ips to allocate for the nat gateway.\n  # If dual-stack is active, at least two ips will be allocated.\n  ips:\n    - name: ip1\n  # defines the concurrent connections per NetworkInterface and target. Must be a power of 2.\n  portsPerNetworkInterface: 64\n  # networkInterfaceSelector selects the target network interfaces that should be NATed.\n  networkInterfaceSelector:\n    matchLabels:\n      key: db\n      foo: bar\nstatus:\n  # ips lists the ips allocated for each requested ip.\n  ips:\n    - name: ip1\n      ips:\n      - 48.86.152.12\n  # portsUsed reports the current port usage of the nat gateway.\n  portsUsed: 128 # Equal to portsPerNetworkInterface * entries in routing destinations\n</code></pre>"},{"location":"proposals/05-object-storage/","title":"IEP-5: Object Storage","text":""},{"location":"proposals/05-object-storage/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/05-object-storage/#summary","title":"Summary","text":"<p>Object storage builds the basis for many cloud applications. An Object Storage provides a simplified object  model for files, but has a reduced set of security and access features (non-posix). This functionality is built on top  of the HTTP protocol. The current market standard is S3.  This document describes how to integrate simplified S3 buckets into the IronCore API without taking too many details of  the S3 feature completeness itself.</p>"},{"location":"proposals/05-object-storage/#motivation","title":"Motivation","text":"<p>Object Storage is demanded by cloud native applications, therefore, IronCore needs to provide it for a complete solution. The Object Storage service should be integrated into IronCore and is not designed  to be just a service on top of IronCore. The used protocol is called S3 which introduces a storage entity called bucket. For the beginning only the bucket creation and removal is covered.</p>"},{"location":"proposals/05-object-storage/#goals","title":"Goals","text":"<ul> <li>S3-compatible object storage implementation</li> <li>Automatic assigned public storage endpoint </li> <li>Providing a REST-API endpoint to address the bucket</li> </ul>"},{"location":"proposals/05-object-storage/#non-goals","title":"Non-Goals","text":"<ul> <li>Support other object storage protocols than S3</li> <li>Internal buckets (reachable only from inside the cluster)</li> <li>Quota handling (size or object number limitation)</li> <li>External Object level access control (beyond what the S3 implementation provides)</li> </ul>"},{"location":"proposals/05-object-storage/#proposal","title":"Proposal","text":"<p>The proposal to provide an Object Storage consists of three API resources: <code>Bucket</code>, <code>BucketClass</code> and <code>BucketPool</code>.  A <code>Bucket</code> is the S3 enabled storage endpoint. IOPS/Bandwidth limitations are controlled via a <code>BucketClass</code> and the  capabilities of the underlying storage provider are expressed via a <code>BucketPool</code>. A <code>Bucket</code> can be requested  from a <code>BucketPool</code> as long as it can provide the performance characteristics described in the <code>BucketClass</code>.  The proposed API resources are similar to <code>Volume</code>, <code>VolumeClass</code> and <code>Volumepool</code> except that a volume is a  block device with a specific driver.</p>"},{"location":"proposals/05-object-storage/#bucket","title":"Bucket","text":"<p>A <code>Bucket</code> is a namespaced resource to request S3-compatible object storage. The desired <code>BucketClass</code> is referenced by the <code>bucketClassRef</code>. If no pool is pre-defined,  the <code>bucketPoolSelector</code> will be used to find a suitable <code>BucketPool</code>.  The desired pool, either pre-defined or  set by another controller, is stated in the <code>bucketPoolRef</code>.</p> <p>The information to access the requested <code>Bucket</code> is in the <code>access</code> field of the status.  The <code>endpoint</code> defines the address of the <code>Bucket</code> Rest-API. Access credentials are placed in a secret with is referenced  through the <code>secretRef</code>. The <code>state</code> indicates if the <code>Bucket</code> is <code>Available</code>, <code>Pending</code> or in an <code>Error</code> state.</p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: Bucket\nmetadata:\n  name: bucket-1\nspec:\n  bucketClassRef:\n    name: slow\n  bucketPoolSelector:\n    matchLabels:\n      key: db\n      foo: bar\n  bucketPoolRef:\n    name: fra-shared\nstatus:\n  access:\n    endpoint: foo.bar.example.org \n    secretRef:\n      name: 000225194345f27a40257c5777c96a03ce219f96731f22afc45b7dfda7d077d\n  state: Available\n</code></pre>"},{"location":"proposals/05-object-storage/#bucketclass","title":"BucketClass","text":"<p>A <code>BucketClass</code> is a non-namespaced resource which describes the characteristics of a <code>Bucket</code>. The maximal  performance the <code>Bucket</code> will offer (like I/O operations or throughput) is defined in the <code>capabilities</code> field.</p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: BucketClass\nmetadata:\n  name: slow\ncapabilities:\n  iops: 10\n  tps: 20Mi\n</code></pre>"},{"location":"proposals/05-object-storage/#bucketpool","title":"BucketPool","text":"<p>A <code>BucketPool</code> is a non-namespaced logical unit and accommodates a collection of <code>Bucket</code>s.  The <code>provider</code>'s id (the implementor's id) of the <code>BucketPool</code> is stated in the <code>providerID</code> field.  Only <code>Bucket</code>s who tolerate all the taints, will land in the <code>BucketPool</code>. <code>BucketClasses</code> which can be fulfilled by  the provider of the <code>BucketPool</code>, are listed in the status field <code>availableBucketClasses</code>. The <code>state</code> in the status  indicates if the pool is <code>Available</code>, <code>Pending</code> or <code>Unavailable</code>.</p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: BucketPool\nmetadata:\n  name: ceph-object-store\nspec:\n  providerID: cephlet://pool\n  taints: []\nstatus:\n  availableBucketClasses:\n    - name: fast\n    - name: slow\n  state: Available\n</code></pre>"},{"location":"proposals/05-object-storage/#alternatives","title":"Alternatives","text":""},{"location":"proposals/06-storage-encryption/","title":"IEP-6: Storage Encryption","text":""},{"location":"proposals/06-storage-encryption/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> </ul>"},{"location":"proposals/06-storage-encryption/#summary","title":"Summary","text":"<p>One of the important feature of Cloud Native IaaS is to provide secure storage. This proposal focuses on providing option to enable encryption for individual ironcore Volume.</p>"},{"location":"proposals/06-storage-encryption/#motivation","title":"Motivation","text":"<p>As part of Storage encryption feature the IronCore API supports option to enable encryption of Volumes. Volume level encryption helps protect users from data theft or accidental loss, by rendering data stored on hard drives unreadable when an unauthorized user tries to gain access. The loss of encryption keys is a major concern, as it can render any encrypted data useless. </p>"},{"location":"proposals/06-storage-encryption/#goals","title":"Goals","text":"<ul> <li>Allow user to enable volume encryption by providing encryption key via secret reference</li> </ul>"},{"location":"proposals/06-storage-encryption/#non-goals","title":"Non-Goals","text":"<ul> <li>Add a new attribute to provide source of encryption key like None/UserProvidedKey/DefaultMasterKey</li> <li>Add KMS support to manage user provided encryption keys</li> </ul>"},{"location":"proposals/06-storage-encryption/#proposal","title":"Proposal","text":"<ul> <li>The proposal introduces a new field <code>encryption</code> with currently the single attribute <code>secretRef</code>, referencing a secret to use for encryption, in existing <code>Volume</code> type. </li> <li><code>encryption</code> is an optional field.</li> <li>If <code>encryption</code> field is not provided by user, then ironcore <code>Volume</code> remains unencrypted</li> <li>To encrypt ironcore <code>Volume</code>, user has to first create kubernetes secret of Opaque type with key-value pair as below:<ul> <li>key = <code>encryptionKey</code> </li> <li>value = base64-encoded 256 bit encryption key</li> </ul> </li> <li>Then provide this secret name to <code>encryption.secretRef</code> attribute of <code>Volume</code> type.</li> </ul> <p>Secret for encryption key</p> <pre><code>apiVersion: v1\nkind: Secret\nmetadata:\n  name: encryption-key-secret\n  namespace: default\ntype: Opaque\ndata:\n  encryptionKey: QW9zejI4Y0xIR3pjR3M2UGltdHZVSnVSSGt6aWZiVTU4V3NIZElIL09idz0=\n</code></pre> <p>Volume with encryption key secret reference:</p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: Volume\nmetadata:\n  name: sample-volume\n  namespace: default\nspec:\n  volumeClassRef:\n    name: fast\n  volumePoolRef:\n    name: ceph\n  resources:\n    storage: 1Gi\n  encryption:\n    secretRef: encryption-key-secret\n</code></pre>"},{"location":"proposals/07-quota/","title":"IEP-7: Quota","text":""},{"location":"proposals/07-quota/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/07-quota/#summary","title":"Summary","text":"<p>Quota is a mechanism to manage and limit the usage of resources across multiple requesting entities. By introducing quotas, a system can be protected from usage spikes and services can be kept responsive. Quotas also can ensure that each requesting entity can exercise its right to a fair share of the resources.</p>"},{"location":"proposals/07-quota/#motivation","title":"Motivation","text":"<p>Kubernetes Resource Quotas are a great way to limit resource consumption for core Kubernetes types (allowing to manage things like overall CPU consumption) and resource count for all types. However, when it comes to limiting resource usage for custom types (in this special case, the <code>ironcore</code> types), the Kubernetes Quota system falls short of providing means to do so.</p> <p>For <code>ironcore</code> it should be possible to limit the actual requested resources like the total number of used CPUs, storage and memory as well as limit the count of resources by a given dimension (e.g. number of <code>Machine</code>s for a given <code>MachineClass</code>).</p>"},{"location":"proposals/07-quota/#goals","title":"Goals","text":"<ul> <li>Limit resource count in a <code>Namespace</code> (by dimension)</li> <li>Limit accumulated resource usage in a <code>Namespace</code> (by dimension)</li> <li>Integrate nicely into the existing Kubernetes <code>ResourceQuota</code> concepts</li> </ul>"},{"location":"proposals/07-quota/#non-goals","title":"Non-Goals","text":"<ul> <li>Limit resource count / accumulated resource usage cross-<code>Namespace</code></li> <li>Define a system to request quota increases</li> <li>Define a user management system</li> <li>Couple resource quota to any user system</li> </ul>"},{"location":"proposals/07-quota/#proposal","title":"Proposal","text":"<p>Introduce a new namespaced type <code>ResourceQuota</code> in the new <code>core</code> group. A <code>ResourceQuota</code> allows defining hard resource limits that cannot be exceeded. The limits are defined via <code>spec.hard</code> as a <code>corev1alpha1.ResourceList</code>. The currently enforced limits are shown in <code>status.hard</code> and the currently used limits in <code>status.used</code>. Requests to create / update resources that would exceed the quota will fail with the HTTP status code <code>403 Forbidden</code>.</p>"},{"location":"proposals/07-quota/#compute-resource-quota","title":"Compute Resource Quota","text":"<p>For the <code>ironcore</code> <code>compute</code> group, the following resources can be limited:</p> Resource Name Description requests.cpu Across all machines in non terminal state, the sum of cpus cannot exceed this value requests.memory Across all machines in non terminal state, the sum of memory cannot exceed this value"},{"location":"proposals/07-quota/#storage-resource-quota","title":"Storage Resource Quota","text":"<p>For the <code>ironcore</code> <code>storage</code> group, the following</p> Resource Name Description requests.storage Across all volumes in non terminal state, the sum of storage cannot exceed this value"},{"location":"proposals/07-quota/#object-count-quota","title":"Object Count Quota","text":"<p>Similar to Kubernetes' object count quota, it is possible to limit the number of resources per types using the following syntax: <code>count/&lt;resource&gt;.&lt;group&gt;</code>. For example, <code>count/machines.compute.ironcore.dev</code> would limit the number of machines from the <code>ironcore</code> <code>compute.ironcore.dev</code> group.</p>"},{"location":"proposals/07-quota/#quota-scopes","title":"Quota Scopes","text":"<p>To measure / limit usage only for a subset of all resources, a <code>ResourceQuota</code> may specify a <code>scopeSelector</code>. A <code>scopeSelector</code> may contain multiple expressions and only matches a resource if it matches the intersection of enumerated scopes.</p> Scope Description MachineClass Match machines that reference the specified machine class VolumeClass Match volumes that reference the specified volume class <p>By using certain <code>scopeSelector</code>s, the quota can only track a specific set of resources. E.g. for the <code>MachineClass</code> <code>scopeSelector</code>, only <code>Machine</code>s can be tracked.</p>"},{"location":"proposals/07-quota/#example-manifests","title":"Example Manifests","text":"<p>Limit the accumulated amount of <code>cpu</code>, <code>memory</code> and <code>storage</code> across all <code>Machine</code>s and <code>Volume</code>s:</p> <pre><code>apiVersion: core.ironcore.dev/v1alpha1\nkind: ResourceQuota\nmetadata:\n  name: limit-accumulated-usage\nspec:\n  hard:\n    requests.cpu: \"1000\"\n    requests.memory: 200Gi\n    requests.storage: 10Ti\n</code></pre> <p>Limit the number of machines for a given machine class:</p> <pre><code>apiVersion: core.ironcore.dev/v1alpha1\nkind: ResourceQuota\nmetadata:\n  name: limit-large-machines\nspec:\n  hard:\n    count/machines.compute.ironcore.dev: 10\n  scopeSelector:\n    matchExpressions:\n    - scopeName: MachineClass\n      operator: In\n      values:\n        - large\n</code></pre>"},{"location":"proposals/08-internal-load-balancer/","title":"IEP-8: Internal Load Balancers","text":""},{"location":"proposals/08-internal-load-balancer/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation</li> <li>Goals</li> <li>Non-Goals</li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/08-internal-load-balancer/#summary","title":"Summary","text":"<p>When developing services in the cloud, not all services should be available to the public internet. Nevertheless they need to be highly available within a certain network boundary.</p> <p>To solve this issue, other public cloud vendors allow defining internal load balancers.</p> <p>Internal load balancers behave much like their external / public counterparts with the important difference of not exposing the selected service to the public internet.</p>"},{"location":"proposals/08-internal-load-balancer/#motivation","title":"Motivation","text":"<p>In <code>ironcore</code>, we need to be able to make services highly available internally. Currently, we can only allocate IP addresses for <code>NetworkInterface</code>s and target them, however, as soon as the backing <code>Machine</code> fails, the service would become unavailable.</p> <p>To prevent this, we have to extend our current <code>LoadBalancer</code> type to also function internally. This should be done with a similar API as for the public use case but allow for the same flexibility with internal IPs as we have already with the <code>NetworkInterface</code> type.</p>"},{"location":"proposals/08-internal-load-balancer/#goals","title":"Goals","text":"<ul> <li> <p>Make a service running on multiple <code>Machine</code>s / <code>NetworkInterface</code>s in a single <code>Namespace</code>   available behind a load-balanced IP without exposing it outside their <code>Network</code></p> </li> <li> <p>Manage the used internal IPs either via literals or by using <code>ipam.Prefix</code>es.</p> </li> <li> <p>Extend the current <code>LoadBalancer</code> type with <code>type: Internal</code> indicating its use as an internal   load balancer.</p> </li> </ul>"},{"location":"proposals/08-internal-load-balancer/#non-goals","title":"Non-Goals","text":"<ul> <li> <p>Cross-Namespace consumption of the <code>LoadBalancer</code> - An internal <code>LoadBalancer</code> is only   available within one <code>Network</code></p> </li> <li> <p>Cross-Namespace IP allocation - IPs and prefixes are created and deleted in a single namespace.</p> </li> <li> <p>Use <code>VirtualIP</code>s in a <code>LoadBalancer</code> of <code>type: Internal</code>:   <code>VirtualIP</code>s are always public (compare to AWS' <code>ElasticIP</code>) and their IP allocation differs   from allocating internal IPs (that don't have to be publicly routable / announced via ASN).   If a user always wants the same internal IP, this use case is already covered by specifying a   literal IP value or by referencing an <code>ipam.Prefix</code>.</p> </li> </ul>"},{"location":"proposals/08-internal-load-balancer/#proposal","title":"Proposal","text":"<p>Example manifest:</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: LoadBalancer\nmetadata:\n  name: my-loadbalancer\nspec:\n  type: Internal\n  networkRef:\n    name: my-network\n  ipFamilies: [IPv4, IPv6]\n  ips:\n  - ip: 10.0.0.1 # It is possible to specify a literal IP\n  - ephemeral: # Or to allocate using an existing ipam.Prefix\n      prefixTemplate:\n        spec:\n          prefixRef: # The prefix length will always = IPFamily.Bits\n            name: my-lb-prefix-v6\n  networkInterfaceSelector:\n    matchLabels:\n      app: web\n  ports: # The port filtering is the same as for public load balancers\n  - protocol: TCP\n    port: 8080\nstatus:\n  ips:\n  - ip: \"10.0.0.1\"\n  - ip: \"2607:f0d0:1002:51::4\"\n</code></pre>"},{"location":"proposals/08-internal-load-balancer/#alternatives","title":"Alternatives","text":"<ul> <li> <p>Target multiple <code>NetworkInterface</code>s + IPs and track (e.g. via discovery / concensus protocol)   which of these are available to solve the high-availability aspect. This has the drawback of   high implementation effort + having to choose from multiple IPs / putting the burden of choosing   the correct IP on a potential consumer.</p> </li> <li> <p>Create <code>Machine</code>(s) that e.g. run <code>HAProxy</code> to target your services with. This comes with the   drawback of having to manage the <code>Machine</code>s / having multiple IPs for the load balancing machines   to choose from (see alternative 1).</p> </li> </ul>"},{"location":"proposals/09-network-peering/","title":"IEP-9: Network Peering","text":""},{"location":"proposals/09-network-peering/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/09-network-peering/#summary","title":"Summary","text":"<p>Network peering is a technique used to interleave two isolated networks, allowing members of both networks to communicate with each other as if they were in the same networking domain. This proposal describes how to introduce network peering to <code>ironcore</code>, building upon the existing concepts that were proposed in the Networking Integration IEP.</p>"},{"location":"proposals/09-network-peering/#motivation","title":"Motivation","text":"<p>Network peering allows members of two networks to communicate with each other without exposing them publicly and without a single point of failure. The networking fabric underneath is used to enable the actual routing. <code>ironcore</code>'s <code>networking</code> API should offer a way to define such a peering.</p>"},{"location":"proposals/09-network-peering/#goals","title":"Goals","text":"<ul> <li>Allow two <code>Network</code>s to communicate with each other without exposing their   routes / addresses publicly and by only using network routing to do so   (i.e. no load-balancing).</li> <li>Be less resource-intensive than comparable solutions like load-balancing /   VPN overlays.</li> </ul>"},{"location":"proposals/09-network-peering/#non-goals","title":"Non-Goals","text":"<ul> <li>Map / transform IP addresses: The peered networks will be interleaved with   each other without any transformation. The owners of the networks are   responsible for keeping the addresses conflict-free. If there are conflicts,   it is up to the networking implementation how to resolve them (e.g. use   a 'local-first' approach for which address / route to use).</li> </ul>"},{"location":"proposals/09-network-peering/#proposal","title":"Proposal","text":"<p>Extend the <code>networking.ironcore.dev.Network</code> resource with a <code>spec.peerings</code> field that specifies the desired network peerings and a <code>status.peerings</code> that reflects the status of these peerings.</p> <p>A peering has a <code>name</code> as handle &amp; primary key (used in <code>StrategicMergePatch</code> and <code>Apply</code>). It references the network to peer with via a <code>networkRef</code> field. This <code>networkRef</code> contains the <code>name</code> and the <code>uid</code> of the target network. If the <code>uid</code> is unset, the <code>Network</code> controller sets this to the <code>uid</code> of the corresponding network upon first reconciliation. This ensures that the same object instances are peered together by verifying the object identity.</p> <p>Both <code>Network</code>s have to specify a matching peering item (i.e. reference each other via <code>networkRef</code>) to mutually accept the peering.</p> <p>The (binding) <code>phase</code> of a <code>spec.peerings</code> item is reflected in a corresponding <code>status.peerings</code> item with the same <code>name</code>. The <code>phase</code> can either be <code>Pending</code>, meaning there is no active peering, or <code>Bound</code>, meaning the peering as described in the <code>spec.peerings</code> item is in place. The <code>lastTransitionTime</code> field is updated every time there is a change in the <code>phase</code>, allowing users and external controllers to determine whether a binding is hanging and to manually delete it if necessary.</p> <p>Example Manifests:</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: Network\nmetadata:\n  name: my-network-1\n  uid: 2020dcf9-e030-427e-b0fc-4fec2016e73a\nspec:\n  peerings:\n  # name is the name of the peering configuration\n  - name: my-network-peering\n    networkRef:\n      name: my-network-2\n      # If unset, uid will be filled in by the Network controller\n      # uid: 3030dcf9-f031-801b-f0f0-4fec2016e73a\nstatus:\n  peerings:\n  - name: my-network-peering\n    # The phase shows the binding progress between two networks.\n    # The initial state is 'Pending' until both peers accept.\n    phase: Bound\n    lastPhaseTransitionTime: \"2023-02-16T15:06:58Z\"\n---\napiVersion: networking.ironcore.dev/v1alpha1\nkind: Network\nmetadata:\n  name: my-network-2\n  uid: 3030dcf9-f031-801b-f0f0-4fec2016e73a\nspec:\n  # Both networks have to have the semantically same peering configuration.\n  peerings:\n  - name: my-network-peering\n    networkRef:\n      name: my-network-1\n      # If unset, uid will be filled in by the Network controller\n      # uid: 2020dcf9-e030-427e-b0fc-4fec2016e73a\nstatus:\n  peerings:\n  - name: my-network-peering\n    phase: Bound\n    lastPhaseTransitionTime: \"2023-02-16T15:06:58Z\"\n</code></pre> <p>Network peering can also specify <code>Network</code>s from different namespaces. For this, the <code>networkRef</code> field includes a <code>namespace</code> field (default empty if in the same namespace). Both <code>Network</code>s need to reference the other network and namespace correctly, otherwise the peering will stay in <code>phase: Pending</code> indefinitely.</p> <p>Example Manifests:</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: Network\nmetadata:\n  namespace: ns-1\n  name: my-network-1\nspec:\n  peerings:\n  - name: my-network-peering\n    networkRef:\n      namespace: ns-2\n      name: my-network-2\n---\napiVersion: networking.ironcore.dev/v1alpha1\nkind: Network\nmetadata:\n  namespace: ns-2\n  name: my-network-2\nspec:\n  peerings:\n  - name: my-network-peering\n    networkRef:\n      namespace: ns-1\n      name: my-network-1\n</code></pre>"},{"location":"proposals/09-network-peering/#alternatives","title":"Alternatives","text":"<ul> <li>Create a VPN overlay between two networks. However, this requires a (potentially   public endpoint and introduces points of failure in form of the VPN server(s)   and client(s). Additionally, the VPN components have to be maintained manually.</li> <li>Use hole-punching to create a bidirectional tunnel. This cannot always be done,   as it depends on the network fabric, requires a publicly available   rendezvous-point, introduces potential points of failure and requires   maintenance for its components as for the VPN-based solution.</li> <li>Depending on the use-case, services can be exposed behind an internal   load-balancer, providing failure-safe and scalable communication channels.</li> </ul>"},{"location":"proposals/10-network-policies/","title":"IEP-10: Network Policies","text":""},{"location":"proposals/10-network-policies/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/10-network-policies/#summary","title":"Summary","text":"<p>In an unregulated network, it is impossible to properly enforce the rules of least-privilege. Each member of a network could potentially communicate to each other, receive traffic from the public internet (if connected) and communicate with the public internet (if connected). This imposes a big security risk which has to be properly addressed in each modern infrastructure. This proposal describes how to introduce network policies as a means to regulate traffic inside a network building upon the existing concepts that were proposed in the Networking Integration IEP.</p>"},{"location":"proposals/10-network-policies/#motivation","title":"Motivation","text":"<p>Currently, there is no way to describe which members of a network should be able to communicate with each other. Same applies to traffic coming from the public internet / going to the public internet. The <code>ironcore</code> should be extended with traffic control mechanisms, allowing to limit / deny traffic on a per-instance basis. Of course, the mechanisms should align well with existing proposals / concepts in the Kubernetes world.</p>"},{"location":"proposals/10-network-policies/#goals","title":"Goals","text":"<ul> <li>Be able to deny ingress and egress traffic between members of a <code>Network</code>.</li> <li>Be able to deny ingress and egress traffic between members of a <code>Network</code> and   the public internet.</li> </ul>"},{"location":"proposals/10-network-policies/#non-goals","title":"Non-Goals","text":"<ul> <li>Define policies that apply to multiple <code>Network</code>s simultaneously.</li> </ul>"},{"location":"proposals/10-network-policies/#proposal","title":"Proposal","text":"<p>Introduce a new type <code>NetworkPolicy</code> that regulates traffic within a certain network. By default, traffic to members in a <code>Network</code> is not regulated. However, as soon as a <code>NetworkPolicy</code> selects members of a <code>Network</code>, all ingress and egress traffic concerning the members is denied unless a <code>NetworkPolicy</code> explicitly allows it. This makes it so multiple <code>NetworkPolicy</code> instances can never be in conflict and instead just allow more ingress / egress traffic to be received / sent.</p> <p>Members are selected using a Kubernetes <code>metav1.LabelSelector</code> to allow specifying multiple target network interfaces.</p> <p>A <code>NetworkPolicy</code> specifies rules to treat <code>ingress</code> and <code>egress</code> traffic. To be able to express whether e.g. no <code>ingress</code> or <code>egress</code> traffic is allowed without specifying any rule, <code>NetworkPolicy</code>s always have to specify the <code>policyTypes</code> (either <code>Ingress</code> / <code>Egress</code>) they want to enforce.</p> <p>Example manifest:</p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: NetworkPolicy\nmetadata:\n  namespace: default\n  name: my-network-policy\nspec:\n  # This specifies the target network to limit the traffic in.\n  networkRef:\n    name: my-network\n  # Only network interfaces in the specified network will be selected.\n  networkInterfaceSelector:\n    matchLabels:\n      app: db\n  # If the policy types are not specified, they are inferred on whether\n  # any ingress / egress rule exists. If no ingress / egress rule exists,\n  # the network policy is denied on admission.\n  policyTypes:\n  - Ingress\n  - Egress\n  # Multiple ingress / egress rules are possible.\n  ingress:\n  - from:\n    # Traffic can be limited from a source IP block.\n    - ipBlock:\n        cidr: 172.17.0.0/16\n    # Traffic can also be limited to objects of the networking api.\n    # For instance, to limit traffic from network interfaces, one could\n    # specify the following:\n    - objectSelector:\n        kind: NetworkInterface\n        matchLabels:\n          app: web\n    # Analogous to network interfaces, it is also possible to limit\n    # traffic coming from load balancers:\n    - objectSelector:\n        kind: LoadBalancer\n        matchLabels:\n          app: web\n    # Ports always have to be specified. Only traffic matching the ports\n    # will be allowed.\n    ports:\n    - protocol: TCP\n      port: 5432\n  egress:\n  - to:\n    - ipBlock:\n        cidr: 10.0.0.0/24\n    ports:\n    - protocol: TCP\n      port: 8080\n</code></pre>"},{"location":"proposals/10-network-policies/#alternatives","title":"Alternatives","text":"<ul> <li>Provide an own networking overlay that enforces the rules. However, this   involves significant effort and maintenance.</li> <li>Have hypervisors / management processes monitor traffic sent by application   processes. However, monitoring of the hypervisors / management processes still   is not addressed with this.</li> </ul>"},{"location":"proposals/11-scheduling/","title":"IEP-11: Reservation-Based Scheduling for <code>Machine</code>s","text":""},{"location":"proposals/11-scheduling/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>Proposal</li> <li>Alternatives</li> </ul>"},{"location":"proposals/11-scheduling/#summary","title":"Summary","text":"<p>Scheduling resources is a central process to increase utilization of cloud infrastructure. It not only involves the  process to find any feasible <code>MachinePool</code> but rather, if possible, to find a <code>MachinePool</code> where the <code>Machine</code> can  be materialized.</p>"},{"location":"proposals/11-scheduling/#motivation","title":"Motivation","text":"<p>With <code>ironcore</code> a multi-level hierarchy can be built to design availability/failure zones. <code>Machine</code>s can be created  on every layer, which are subsequently scheduled on <code>MachinePool</code>s  in the hierarchy below.  A scheduler on every  layer should assign a <code>Machine</code> on a <code>MachinePool</code> which can fulfill it.  This proposal addresses the known  limitations of the current implementation: - API changes needed to extend the scheduling if further resources should be considered - Available resources are attached to <code>Pools</code> and aggregated. In higher levels a correct decision can't be made    which means that <code>Machine</code>s are assigned to saturated <code>Pool</code>s.</p>"},{"location":"proposals/11-scheduling/#goals","title":"Goals","text":"<ul> <li>Dynamic (<code>NetworkInterfaces</code>, <code>LocalDiskStorage</code>) and static resources (resources defined by a <code>Class</code> like <code>CPU</code>,    <code>Memory</code>) should be taken into the scheduling decision.</li> <li>Scheduling should be robust against data race conditions</li> <li><code>Machine</code>s on every level should be scheduled on a <code>Pool</code></li> <li>It should be possible to add resources influencing the scheduling decision without API change</li> <li>Resource updates of <code>Pool</code>s should be possible</li> <li>Adding/removing of compute <code>Pool</code>s should be possible</li> </ul>"},{"location":"proposals/11-scheduling/#non-goals","title":"Non-Goals","text":"<ul> <li>The scheduler should not act on <code>Machine</code> updates like <code>NetworkInterface</code> attachments</li> <li>This proposal does not cover the scheduling of <code>Volumes</code>.</li> </ul>"},{"location":"proposals/11-scheduling/#proposal","title":"Proposal","text":"<p>For every created <code>Machine</code> with an empty <code>spec.machinePoolRef</code>, the scheduler will create a resource <code>Reservation</code>.  The <code>poollet</code> will continue to broker only <code>Machine</code>s with a <code>.spec.machinePoolRef</code> set. The <code>Reservation</code> is a  condensed derivation of a <code>Machine</code> containing the requested resources like <code>NetworkInterfaces</code> and the attached  <code>MachineClass</code> resource list. The <code>IRI</code> will be extended to be able to manage the <code>Reservation</code>s. Once the  <code>Reservation</code> hits a pool provider (e.g. <code>libvirt-provider</code>), the decision can be made if the <code>Reservation</code> can be  fulfilled or not. In case of accepting the <code>Reservation</code>, resources needs to be blocked until:  1. the corresponding <code>Machine</code> is being placed on the pool provider. 2. the reservation is being deleted </p> <p>The status of the <code>Reservation</code> is being propagated up to the layer where it was created. As soon as the root  reservation has a populated status which contains a list of possible pools, the scheduler can pick one, set the  <code>Machine.spec.machinePoolRef</code> and the <code>poollet</code> will broker the <code>Machine</code> to the next level.</p> <p><code>Reservation</code> resource:  <pre><code>apiVersion: core.ironcore.dev/v1alpha1\nkind: Reservation\nmetadata:\n  namespace: default\n  name: reservation\nspec:\n  # Pools define each pool where resources should be reserved\n  pools: \n    - poolA\n    - poolB\n    - poolC\n  # Resources defines the requested resources in a ResourceList\n  resources:\n    localStorage: 10G\n    nics: 2\n    cpu: 2\nstatus:\n  # Pools describe where the resource reservation was possible\n  pools: \n    - name: poolA\n      state: Accepted\n    - name: poolB\n      state: Rejected\n</code></pre></p> <p><code>Reservation</code> states: - Accepted: The <code>Reservation</code> can be materialized on this <code>pool</code>. - Rejected: The <code>Reservation</code> can not be materialized on this <code>pool</code>. - Bound: The corresponding <code>Machine</code> replaced the <code>Reservation</code> which indicates that the <code>Reservation</code> can be    cleaned up.</p> <p>Added <code>IRI</code> methods:</p> <pre><code>rpc ListReservations(ListReservationsRequest) returns (ListReservationsResponse) {};\nrpc CreateReservation(CreateReservationRequest) returns (CreateReservationResponse) {};\nrpc DeleteReservation(DeleteReservationRequest) returns (DeleteReservationResponse) {};\n</code></pre>"},{"location":"proposals/11-scheduling/#detailed-flow","title":"Detailed flow","text":"<p>The flow to assign a <code>Machine</code> to a <code>Pool</code> consists of 3 Phases:  </p>"},{"location":"proposals/11-scheduling/#1-reservation-flow","title":"1. Reservation Flow","text":"<ol> <li>If <code>.spec.machinePoolRef</code> is not set, the scheduler creates a <code>Reservation</code> that includes the required resources.</li> <li><code>poollet</code>s which match <code>.spec.pools</code> of <code>Reservation</code> pick it up and broker it one layer down. If the <code>.spec. pools</code> is empty, it is considered as a wildcard for all pools.</li> <li><code>provider</code> evaluates the <code>Reservation</code> and sets its state to <code>Accepted</code> or <code>Rejected</code>, which is then     propagated up the hierarchy.</li> </ol>"},{"location":"proposals/11-scheduling/#2-scheduling-flow","title":"2. Scheduling Flow","text":"<ol> <li>On every layer, the scheduler uses a <code>Reservation</code> corresponding to a <code>Machine</code> to select a <code>MachinePool</code>. It     will pick one of the <code>Accepted</code> pools of the <code>Reservation.status.pools</code> and updates the <code>Machine.spec.    machinePoolRef</code>.</li> <li><code>poollet</code> picks up the <code>Machine</code> since <code>.spec.machinePoolRef</code> is set</li> <li>Once a <code>Machine</code> reaches a <code>provider</code> with a relating <code>Reservation</code>, the <code>Reservation</code> will be replaced through    the <code>Machine</code>. <code>Reservation</code> status will be updated to <code>Bound</code> and <code>poollet</code>s pulls the status up until to the     root <code>Reservation</code>.</li> </ol>"},{"location":"proposals/11-scheduling/#3-cleanup-flow","title":"3.  Cleanup Flow","text":"<ol> <li>The scheduler deletes root <code>Reservation</code> if <code>Machine</code> has <code>.spec.machinePoolRef</code> and if <code>Reservation</code> has a     <code>Bound</code> state.</li> </ol>"},{"location":"proposals/11-scheduling/#advantages","title":"Advantages","text":"<ul> <li>In case of a partial outage/network issues <code>Machine</code>s can be placed on other <code>Pool</code>s</li> <li><code>Pool</code>s do not leak resource information, owner of resources decides if <code>Reservation</code> can be fulfilled (less complexity for over provisioning)</li> <li><code>Reservation</code>s can be used to block resources without creating a <code>Machine</code></li> </ul>"},{"location":"proposals/11-scheduling/#disadvantages","title":"Disadvantages","text":"<ul> <li>Increases complexity in the scheduling by introducing a new resource (Reservation) and the scheduler flow has to be extended.</li> </ul>"},{"location":"proposals/11-scheduling/#alternatives","title":"Alternatives","text":"<p>Another solution: The providers (in the lowest layer) announce there resources to a central cluster. In these clusters a <code>shallow</code> pool represent the actual compute pool. In fact the problem of scheduling across multi-levels is transformed in a one-layer scheduling decision.  Pools between the root cluster and the leaf clusters are announced but only to represent the hierarchy and not for the actual scheduling.</p> <p>If a <code>Machine</code> is created, a controller creates a related <code>Machine</code> in the central cluster where the <code>Pool</code> is being picked. The <code>Pool</code> is synced back and the<code>.spec.machinePoolRef</code> being set. The <code>poollet</code> syncs the <code>Machine</code> one layer down. In every subsequent layer the path is being looked up in the central cluster until the provider is hit.</p>"},{"location":"proposals/11-scheduling/#advantages_1","title":"Advantages","text":"<ul> <li>Scheduling in central place is simpler</li> <li>Availability/failure zones can be modeled in central cluster</li> <li>(Scheduling decision takes potentially less time?)</li> </ul>"},{"location":"proposals/11-scheduling/#disadvantages_1","title":"Disadvantages","text":"<ul> <li>Resources are populated to central place and consistency needs to be guaranteed</li> <li>Updates are harder (failure of provider, overbooking)</li> <li>Bookkeeping of resources needs to happen twice: in provider and central place </li> <li>Layered structure of hierarchy needs to be duplicated at central place</li> <li>If central cluster is not reachable, no <code>Machine</code> can be placed</li> <li>No easy way to dynamically change pool hierarchy.</li> <li>Leaf <code>poollet</code> configuration/behaviour will differ from other <code>poollet</code>s </li> </ul>"},{"location":"proposals/12-volumesnapshots/","title":"IEP-12: Introducing <code>VolumeSnapshot</code> type and Restoration Paths","text":""},{"location":"proposals/12-volumesnapshots/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Summary</li> <li>Motivation<ul> <li>Goals</li> <li>Non-Goals</li> </ul> </li> <li>API Design</li> <li><code>VolumeSnapshot</code> Resource</li> <li><code>Volume</code> Resource Enhancement</li> <li><code>VolumeRuntime</code> enhancement</li> <li>Implementation Strategy</li> <li>Alternatives</li> </ul>"},{"location":"proposals/12-volumesnapshots/#summary","title":"Summary","text":"<p>We propose the introduction of new resource to the IronCore project: <code>VolumeSnapshot</code>. The <code>VolumeSnapshot</code>  resource would allow users to take point-in-time snapshots of the content of a <code>Volume</code>. We also propose an  enhancement to the <code>Volume</code> resource to provide a path for restoring from a <code>VolumeSnapshot</code>. These new resources  and changes would provide users with increased capabilities for data protection and disaster recovery.</p>"},{"location":"proposals/12-volumesnapshots/#motivation","title":"Motivation","text":"<p>The IronCore project currently provides interfaces for managing resources such as <code>Volumes</code>, <code>VolumeClasses</code> and <code>VolumePools</code>.  A <code>VolumePool</code> is a representation of a <code>VolumePool</code> provider that materializes the requested <code>Volume</code> in an underlying storage implementation. A <code>VolumePool</code> provider here announces the supported <code>VolumeClasses</code> to indicate to the user which performance characteristics of <code>Volumes</code> this particular <code>VolumePool</code> can offer. There is currently no direct way to snapshot the content of a <code>Volume</code>, nor is there a method  for defining different types of snapshots or restoring from a snapshot, which potentially puts user's data at risk.</p>"},{"location":"proposals/12-volumesnapshots/#goals","title":"Goals","text":"<ul> <li>Allow the user to take point-in-time snapshots of the content of a <code>Volume</code>.</li> <li>Allow the user to restore a <code>Volume</code> from a snapshot.</li> <li>Hide provider-specific details of snapshot management from the user.</li> <li>For encrypted <code>Volumes</code>, reuse the existing encryption key of the <code>Volume</code> when restoring from a snapshot.</li> </ul>"},{"location":"proposals/12-volumesnapshots/#non-goals","title":"Non-Goals","text":"<ul> <li>Incremental snapshots of <code>Volumes</code>.</li> <li>Restore an existing <code>Volume</code> from a snapshot.</li> </ul>"},{"location":"proposals/12-volumesnapshots/#api-design","title":"API Design","text":""},{"location":"proposals/12-volumesnapshots/#volumesnapshot-resource","title":"<code>VolumeSnapshot</code> Resource","text":"<p>The <code>VolumeSnapshot</code> resource will have the following structure:</p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: VolumeSnapshot\nmetadata:\n  name: example-snapshot\n  namespace: default\nspec:\n  volumeRef:\n    name: example-volume\nstatus:\n  snapshotID: 029321790472c133de32f05944bc2543629fe4b4264dc42f8d95a87adbba265\n  state: Pending/Ready/Failed\n  size: 10Gi\n  lastStateTransitionTime: 2025-08-20T08:24:25Z\n</code></pre>"},{"location":"proposals/12-volumesnapshots/#fields","title":"Fields:","text":"<ul> <li><code>volumeRef</code>: Reference to the <code>Volume</code> to be snapshot. The <code>VolumeSnapshot</code> and <code>Volume</code> should be in the same namespace.</li> <li><code>snapshotID</code>: Reference to the storage-provider specific snapshot object.</li> <li><code>status.state</code>: The current phase of the snapshot. It can be <code>Pending</code>, <code>Ready</code> or <code>Failed</code>.</li> <li><code>Pending</code>: The snapshot resource has been created, but the snapshot has not yet been initiated.</li> <li><code>Ready</code>: The snapshot has been successfully created and is ready for use.</li> <li><code>Failed</code>: The snapshot creation has failed.</li> <li><code>status.size</code>: The size of the data in the snapshot. This will be populated by the system once the snapshot is ready.</li> </ul>"},{"location":"proposals/12-volumesnapshots/#volume-resource-enhancement","title":"Volume Resource Enhancement","text":"<p>The <code>Volume</code> resource will have 2 new volume data source inline fields as <code>volumeSnapshotRef</code> and <code>osImage</code> under <code>spec</code>:</p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: Volume\nmetadata:\n  name: restored-volume\n  namespace: default\nspec:\n  volumeClassRef:\n    name: example-volumeclass\n  volumeSnapshotRef:\n    name: example-snapshot\n  osImage: test-image\n</code></pre>"},{"location":"proposals/12-volumesnapshots/#fields_1","title":"Fields:","text":"<ul> <li><code>volumeSnapshotRef</code>: Indicates to use the specified <code>VolumeSnapshot</code> as the data source.</li> <li><code>osImage</code>: It is an os image to bootstrap the volume.</li> </ul>"},{"location":"proposals/12-volumesnapshots/#volumeruntime-enhancement","title":"<code>VolumeRuntime</code> enhancement","text":"<p>To support the creation and restoration of <code>VolumeSnapshot</code> resources, the <code>VolumeRuntime</code> interface will be  enhanced to include methods for:</p> <ul> <li>Creating a <code>VolumeSnapshot</code> from a <code>Volume</code>.</li> <li>Deleting a <code>VolumeSnapshot</code>.</li> <li>Restoring a <code>Volume</code> from a <code>VolumeSnapshot</code>.</li> </ul> <pre><code>service VolumeRuntime {\n  // CreateVolumeRequest needs to be updated to include a dataSource field to support restoration from a snapshot \n  // when creating a new Volume.\n  rpc CreateVolume(CreateVolumeRequest) returns (CreateVolumeResponse) {};\n\n  // CreateVolumeSnapshot will be used to create a snapshot of a Volume.\n  rpc CreateVolumeSnapshot(CreateVolumeSnapshotRequest) returns (CreateVolumeSnapshotResponse) {};\n  // DeleteVolumeSnapshot will be used to delete a snapshot and its associated content.\n  rpc DeleteVolumeSnapshot(DeleteVolumeSnapshotRequest) returns (DeleteVolumeSnapshotResponse) {};\n  // ListVolumeSnapshots will be used to list all snapshots managed by the volume provider\n  rpc ListVolumeSnapshots(ListVolumeSnapshotsRequest) returns (ListVolumeSnapshotsResponse) {};\n}\n</code></pre>"},{"location":"proposals/12-volumesnapshots/#implementation-strategy","title":"Implementation Strategy","text":"<p>Once the proposal is approved, the implementation will follow these stages:</p> <ol> <li>Define the <code>VolumeSnapshot</code> resource in the <code>ironcore</code> project.</li> <li>Extend the <code>VolumeRuntime</code> interface to support snapshot creation and restoration.</li> <li>Implement the runtime interface methods in the <code>volume-broker</code> component</li> <li>Implement the runtime interface methods in the respective storage provider components.</li> <li>Implement the <code>volumepoollet</code> to react on the new API types and handle the creation, deletion, and restoration of  snapshots by invoking the appropriate methods in the <code>VolumeRuntime</code> interface.</li> </ol>"},{"location":"proposals/12-volumesnapshots/#alternatives","title":"Alternatives","text":"<p>Potential alternatives to the proposed changes could include:</p> <ol> <li>Third-Party Snapshot Tools: One alternative to implementing a <code>VolumeSnapshot</code> resource could be  to recommend users leverage existing third-party tools or cloud-provider services for managing snapshots. However,  this approach might lack the integration and ease of use that come with an inbuilt solution.</li> <li>Application-Level Snapshots: Another alternative could be to allow applications to manage their own snapshots and backups on an application level.</li> <li>Extend <code>Volume</code> Resource: Rather than introducing new resources, we could extend the current <code>Volume</code> resource  with snapshot-related functionalities. This could include adding fields to the <code>Volume</code> spec that would trigger a  snapshot when certain conditions are met. However, this could potentially complicate the <code>Volume</code> resource and would  limit the flexibility to manage snapshots independently.</li> <li>Storage Provider Level Snapshots: Leave the task of snapshot creation and management to individual storage  providers. Each storage provider has its own way of managing snapshots, and they could provide their own APIs for  managing them. This might complicate things for users who have to work with different APIs for different  storage providers.</li> </ol> <p>Please note that these alternatives come with their own sets of advantages and disadvantages, and a thorough evaluation  should be conducted to select the most appropriate solution.</p>"},{"location":"usage/installation/","title":"Installing Ironcore","text":""},{"location":"usage/installation/#requirements","title":"Requirements","text":"<ul> <li><code>go</code> &gt;= 1.20</li> <li><code>git</code>, <code>make</code>, and <code>kubectl</code></li> <li>Kustomize</li> <li>Access to a Kubernetes cluster (Minikube, kind or a real cluster)</li> </ul>"},{"location":"usage/installation/#clone-the-repository","title":"Clone the Repository","text":"<p>To bring up and install the <code>Ironcore</code> project, you first need to clone the repository.</p> <pre><code>git clone git@github.com:ironcore-dev/ironcore.git\ncd ironcore\n</code></pre>"},{"location":"usage/installation/#install-cert-manager","title":"Install cert-manager","text":"<p>If there is no cert-manager present in the cluster it needs to be installed.</p> <pre><code>kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.16.2/cert-manager.yaml\n</code></pre>"},{"location":"usage/installation/#install-apis-into-the-cluster","title":"Install APIs into the Cluster","text":"<p>Your Kubernetes API server needs to know about the APIs that come with the <code>Ironcore</code> project. To install the APIs into your cluster, run</p> <pre><code>make install\n</code></pre> <p>Note: This requires the <code>APISERVER_IMG</code> (Makefile default set to <code>apiserver</code>) to be pullable from your Kubernetes cluster. For local development with <code>kind</code>, a make target that builds and loads the API server image and then applies the manifests is available via</p> <pre><code>make kind-install\n</code></pre> <p>Note: In case multiple environments running, ensure that <code>kind get clusters</code> is pointing to the default kind cluster.</p>"},{"location":"usage/installation/#deploy-the-controller-manager","title":"Deploy the Controller Manager","text":"<p>The controller manager can be started via the following command.</p> <pre><code>make kind-deploy\n</code></pre>"},{"location":"usage/installation/#validate","title":"Validate","text":"<p>Make sure you have all the below pods running.</p> <pre><code>$ kubectl get po -n ironcore-system\nNAME                                           READY   STATUS    RESTARTS       AGE\nironcore-apiserver-85995846f9-47247            1/1     Running   0              136m\nironcore-controller-manager-84bf4cc6d5-l224c   2/2     Running   0              136m\nironcore-etcd-0                                1/1     Running   0              143m\n</code></pre>"},{"location":"usage/installation/#apply-sample-manifests","title":"Apply Sample Manifests","text":"<p>The <code>config/samples</code> folder contains samples for all APIs supported by this project. You can apply any of the samples by running</p> <pre><code>kubectl apply -f config/samples/SOME_RESOURCE.yaml\n</code></pre>"},{"location":"usage/installation/#cleanup","title":"Cleanup","text":"<p>To remove the APIs from your cluster, simply run.</p> <pre><code>make uninstall\n</code></pre>"},{"location":"usage/compute/machine/","title":"Machine","text":"<p>A <code>Machine</code> resource in <code>Ironcore</code> is used to represent a compute resource or a virtual machine.  It serves as a means to configure network, storage, type of machine and other information needed to create a VM. The <code>MachineController</code> reconciler leverages this information to determine where the machine needs to be created and the type of machine that needs to be created along with the required <code>Network</code> and <code>Storage</code> configuration which will be further passed to respective <code>NetworkController</code> and <code>StorageController</code>.</p>"},{"location":"usage/compute/machine/#example-machine-resource","title":"Example Machine Resource","text":"<p>An example of how to define a Machine resource:</p> <p><pre><code>apiVersion: compute.ironcore.dev/v1alpha1\nkind: Machine\nmetadata:\n  name: machine-sample\nspec:\n  machineClassRef:\n    name: machineclass-sample\n  image: my-image\n  volumes:\n    - name: rootdisk # first disk is the root disk\n      volumeRef:\n        name: my-volume\n  networkInterfaces:\n    - name: primary\n      networkInterfaceRef:\n        name: networkinterface-sample\n  ignitionRef:\n    name: my-ignition-secret\n</code></pre> (<code>Note</code>: Refer to E2E Examples for more detailed examples.)</p> <p>Key Fields:</p> <ul> <li>machineClassRef (<code>string</code>): machineClassRef is a reference to the machine class/flavor of the machine.</li> <li>machinePoolRef (<code>string</code>): machinePoolRef defines the machine pool to run the machine in. If empty, a scheduler will figure out an appropriate pool to run the machine in.</li> <li>image (<code>string</code>): image is the optional URL providing the operating system image of the machine.</li> <li>volumes (<code>list</code>): volumes are list volumes(storage) attached to this machine.</li> <li>networkInterfaces (<code>list</code>): networkInterfaces define a list of network interfaces present on the machine</li> <li>ignitionRef (<code>string</code>): ignitionRef is a reference to a <code>secret</code> containing the ignition YAML for the machine to boot up. If a key is empty, <code>DefaultIgnitionKey</code> will be used as a fallback. (<code>Note</code>: Refer to Sample Ignition for creating ignition secret)</li> </ul>"},{"location":"usage/compute/machine/#reconciliation-process","title":"Reconciliation Process","text":"<ol> <li>Machine Scheduling:  The <code>MachineScheduler</code> controller continuously watches for <code>Machines</code> without an assigned <code>MachinePool</code> and tries to schedule it on available and matching MachinePool.</li> <li>Monitor Unassigned Machines: The scheduler continuously watches for machines without an assigned <code>machinePoolRef</code>.</li> <li>Retrieve Available Machine Pools: The scheduler fetches the list of available machine pools from the cache.</li> <li>Make Scheduling Decisions: The scheduler selects the most suitable machine pool based on resource availability and other policies.</li> <li>Update Cache: The scheduler updates the cache with recalculated allocatable <code>machineClass</code> quantities.</li> <li> <p>Assign MachinePoolRef: The scheduler assigns the selected <code>machinePoolRef</code> to the machine object.</p> </li> <li> <p>IRI Machine Creation and Brokering: </p> </li> <li>The Machine is allocated to a particular pool via the scheduler. </li> <li>The <code>machinepoollet</code> responsible for this pool picks up the <code>Machine</code> resource and extracts the <code>ignitionData</code>, <code>networkInterfaces</code> and <code>volumes</code> information from the <code>spec</code> and prepares the IRI machine object. </li> <li>Once the IRIMachine object is prepared the machine create/update request is sent to a broker via the IRI interface(via GRPC call) either against a broker (to copy the resource into another cluster) OR a provider implementation e.g. libvirt-provider which creates a corresponding machine against libvirt/QEMU. </li> <li> <p>Once the response is received from IRI call Machine status is updated with the status received.</p> </li> <li> <p>Network Interface handling: <code>MachineControllerNetworkinterface</code> takes care of attaching/detaching Network interfaces defined for the machine. Once the attachment is successful status is updated from <code>Pending</code> to <code>Attached</code>.</p> </li> <li> <p>Volume handling: <code>MachineControllerVolume</code> takes care of attach/detach of Volumes(Storage) defined for machine. Once the attachment is successful status is updated from <code>Pending</code> to <code>Attached</code>.</p> </li> <li> <p>Ephemeral resource handling: </p> </li> <li>The <code>Volume</code> and <code>NetworkIntreface</code> can be bound with the lifecycle of the Machine by creating them as ephemeral resources. (<code>Note</code>: For more details on how to create ephemeral resources refer to Machine with ephemeral resources)</li> <li>If <code>NetworkIntreface</code> or <code>Volume</code> is defined as ephemeral <code>MachineEphemeralControllers</code> takes care of creating and destroying respective objects on creation/deletion of the machine. </li> </ol>"},{"location":"usage/compute/machine/#lifecycle-and-states","title":"Lifecycle and States","text":"<p>A Machine can be in the following states: 1. Pending:  A Machine is in a Pending state when the Machine has been accepted by the system, but not yet completely started. This includes time before being bound to a MachinePool, as well as time spent setting up the Machine on that MachinePool.  2. Running: A Machine in Running state when the machine is running on a MachinePool. 2. Shutdown: A Machine is in a Shutdown state. 3. Terminating: A Machine is Terminating. 2. Terminated: A Machine is in the Terminated state when the machine has been permanently stopped and cannot be started.</p>"},{"location":"usage/compute/machineclass/","title":"MachineClass","text":"<p>A <code>MachineClass</code> is an <code>Ironcore</code> resource used to represent a class/flavor of a Machine. It serves as a means to define the number of resources a <code>Machine</code> object can have as capabilities(For eg, CPU, memory) associated with a particular class. The <code>MachineClassController</code> reconciler leverages this information to create <code>MachineClass</code>.</p>"},{"location":"usage/compute/machineclass/#example-machine-resource","title":"Example Machine Resource","text":"<p>An example of how to define a MachineClass resource:</p> <pre><code>apiVersion: compute.ironcore.dev/v1alpha1\nkind: MachineClass\nmetadata:\n  name: machineclass-sample\ncapabilities:\n  cpu: 4\n  memory: 16Gi\n</code></pre> <p>Key Fields:</p> <ul> <li>capabilities (<code>ResourceList</code>): capabilities are used to define a list of resources a Machine can have along with its capacity.</li> </ul>"},{"location":"usage/compute/machineclass/#reconciliation-process","title":"Reconciliation Process","text":"<ul> <li>MachineClass Creation: The <code>MachineClassController</code> uses the <code>capabilities</code> field in the MachineClass resource to create a flavor of MachineClass resource.</li> <li>MachineClass Deletion: Before deleting any MachineClass it's been ensured that it is not in use by any <code>Machine</code> and then only deleted.</li> </ul>"},{"location":"usage/compute/machinepool/","title":"MachinePool","text":"<p>A <code>MachinePool</code> is a resource in <code>Ironcore</code> that represents a pool of compute resources managed collectively. It defines the infrastructure's compute configuration used to provision and manage <code>Machines</code>, ensuring resource availability and compatibility with associated <code>MachineClasses</code>. (<code>Note</code>: One <code>machinepoollet</code> is responsible for one <code>MachinePool</code>)</p>"},{"location":"usage/compute/machinepool/#example-machinepool-resource","title":"Example MachinePool Resource","text":"<p>An example of how to define a MachinePool resource:</p> <pre><code>apiVersion: compute.ironcore.dev/v1alpha1\nkind: MachinePool\nmetadata:\n  name: machinepool-sample\n  labels:\n    ironcore.dev/az: az1\nspec:\n  providerID: ironcore://shared\n</code></pre> <p>Key Fields:</p> <ul> <li><code>ProviderID</code>(<code>string</code>):  The <code>providerId</code> helps the controller identify and communicate with the correct compute system within the specific backend compute provider. For example <code>ironcore://shared</code></li> </ul>"},{"location":"usage/compute/machinepool/#reconciliation-process","title":"Reconciliation Process","text":"<ul> <li>Machine Type Discovery: It constantly checks what kinds of <code>MachineClasses</code> are available in the <code>Ironcore</code> Infrastructure</li> <li>Compatibility Check: Evaluating whether the <code>MachinePool</code> can manage available machine classes based on its capabilities. </li> <li>Status Update: Updating the MachinePool's status to indicate the supported <code>MachineClasses</code> with available capacity and allocatable.</li> <li>Event Handling: Watches for changes in MachineClass resources and ensures the associated MachinePool is reconciled when relevant changes occur.</li> </ul>"},{"location":"usage/core/resourcequota/","title":"ResourceQuota","text":"<p>A <code>ResourceQuota</code> in <code>Ironcore</code> provides a mechanism to manage and limit the usage of resources across multiple requesting entities. This allows to protect a system from usage spikes and services can be kept responsive. With the help of <code>ResourceQuota</code> user can define a hard limit with list of resources along with <code>ScopeSelector</code>. The <code>ResourcequotaController</code> reconciler leverages this information to create a ResourceQuota in Ironcore infrastructure. (<code>Note</code>: ResourceQuota is a namespaced resource and it can only limit resource count/accumulated resource usage within deifned namespace)</p>"},{"location":"usage/core/resourcequota/#example-resourcequota-resource","title":"Example ResourceQuota Resource","text":"<p>An example of how to define a <code>ResourceQuota</code> in <code>Ironcore</code> <pre><code>apiVersion: core.ironcore.dev/v1alpha1\nkind: ResourceQuota\nmetadata:\n  name: resource-quota-sample\nspec:\n  hard: # Hard is the mapping of strictly enforced resource limits.\n    requests.cpu: \"10\"\n    requests.memory: 100Gi\n    requests.storage: 10Ti\n</code></pre></p>"},{"location":"usage/core/resourcequota/#key-fields","title":"Key Fields:","text":"<ul> <li><code>hard</code>(<code>ResourceList</code>): hard is a <code>ResourceList</code> of the strictly enforced number of resources. <code>ResourceList</code> is a list of ResourceName alongside their resource quantity.</li> <li><code>scopeSelector</code>(<code>ResourceScopeSelector</code>): scopeSelector selects the resources that are subject to this quota. (<code>Note</code>: By using scopeSelectors, only certain resources may be tracked.)</li> </ul> <p>(<code>Note</code>: Refer to API Reference for more detailed description of <code>ResourceList</code> and <code>ResourceScopeSelector</code>.)</p>"},{"location":"usage/core/resourcequota/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li>Gathering matching evaluators: ResourcequotaController retrieves all the matching evaluators from the registry for the specified resources in hard spec. Each resource evaluator implements set of Evaluator interface methods which helps in retrieving the current usage of that perticular resource type.</li> <li>Calculating resource usage: Resource usage is calculated by iterating over each evaluator and listing the namespace resource of that particular type. Listed resources are then filtred out by matching specified scope selector and accumulated usage is calculated. </li> <li>Status update: Once usage data is available resource quota status is updated with the enforced hard resource limits and currently used resources.</li> <li>Resource quota handling: On request of create/update resources whether to allow create/update based on resource quota usage is handled via admission controller. Resources that would exceed the quota will fail with the HTTP status code 403 Forbidden.</li> </ul>"},{"location":"usage/ipam/prefix/","title":"Prefix","text":"<p>A <code>Prefix</code> resource provides a fully integrated IP address management(IPAM) solution for <code>Ironcore</code>. It serves as a means to define IP prefixes along with prefix length to a reserved range of IP addresses. It is also possible to define child prefixes with the specified prefix length referring to the parent prefix.</p>"},{"location":"usage/ipam/prefix/#example-volume-resource","title":"Example Volume Resource","text":"<p>An example of how to define a root <code>Prefix</code> resource in <code>Ironcore</code></p> <p><pre><code>apiVersion: ipam.ironcore.dev/v1alpha1\nkind: Prefix\nmetadata:\n  name: root\n  labels:\n    root-prefix: customer-1\nspec:\n  prefix: 10.0.0.0/24\n</code></pre> An example of how to define a child <code>Prefix</code> resource in <code>Ironcore</code></p> <p><pre><code>apiVersion: ipam.ironcore.dev/v1alpha1\nkind: Prefix\nmetadata:\n  name: child-prefix\nspec:\n  ipFamily: IPv4\n  prefixLength: 9\n  parentSelector:\n    matchLabels:\n      root-prefix: customer-1\n</code></pre> (<code>Note</code>: Refer to E2E Examples for more detailed example on IPAM to understant e2e flow)</p>"},{"location":"usage/ipam/prefix/#key-fields","title":"Key Fields:","text":"<ul> <li> <p><code>ipFamily</code>(<code>string</code>): <code>ipFamily</code> is the IPFamily of the prefix. If unset but <code>prefix</code> is set, this can be inferred.</p> </li> <li> <p><code>prefix</code> (<code>string</code>):  <code>prefix</code> is the IP prefix to allocate for this Prefix.</p> </li> <li> <p><code>prefixLength</code> (<code>int</code>): <code>prefixLength</code> is the length of prefix to allocate for this Prefix.</p> </li> <li> <p><code>parentRef</code> (<code>string</code>): <code>parentRef</code> references the parent to allocate the Prefix from. If <code>parentRef</code> and <code>parentSelector</code> is empty, the Prefix is considered a root prefix and thus allocated by itself.</p> </li> <li> <p><code>parentSelector</code> (<code>LabelSelector</code>): <code>parentSelector</code> is the LabelSelector to use for determining the parent for this Prefix.</p> </li> </ul>"},{"location":"usage/ipam/prefix/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li> <p>Allocate root prefix: If <code>parentRef</code> and <code>parentSelector</code> is empty, the PrefixController reconciler considers it as a root prefix and allocates by itself and the status is updated as <code>Allocated</code>.</p> </li> <li> <p>Allocating sub-prefix: If <code>parentRef</code> or <code>parentSelector</code> is set PrefixController lists all the previously allocated prefix allocations by parent prefix. Finds all the active allocations and prunes outdated ones. If no existing PrefixAllocation object is found new <code>PrefixAllocation</code> object is created for the new prefix to allocate. If prefix allocation is successful status is updated to <code>Allocated</code> otherwise to <code>Failed</code>.</p> </li> <li> <p>Prefix allocation scheduler: <code>PrefixAllocationScheduler</code> continuously watches for Prefix resource and tries to schedule all PrefixAllocation objects for which prefix is not yet allocated. PrefixAllocationScheduler determines suitable prefix for allocation by listing available prefixes based on label filter, namespace and desired IP family. Once a suitable prefix is found PrefixAllocation spec.parentRef is updated with the selected prefix reference.</p> </li> <li> <p>Status update: Once prefix allocation is successful status is updated to <code>Allocated</code>. In the case of sub-prefixes once the prefix is allocated <code>PrefixController</code> updates the parent Prefix's status with the used prefix IPs list.</p> </li> </ul> <p>Below is the sample <code>Prefix.status</code> :</p> <pre><code>status:\n  lastPhaseTransitionTime: \"2024-10-21T20:56:24Z\"\n  phase: Allocated\n  used:\n  - 10.0.0.1/32\n  - 10.0.0.2/32\n</code></pre>"},{"location":"usage/networking/loadbalancer/","title":"LoadBalancer","text":"<p>A <code>LoadBalancer</code> resource is an L3(IP-based) load balancer service implementation provided by Ironcore. It provides an externally accessible IP address that sends traffic to the correct port on your cluster nodes. Ironcore LoadBalancer allows targeting multiple <code>NetworkInterfaces</code> and distributes traffic between them. This LoadBalancer supports dual stack IP addresses (IPv4/IPv6). </p>"},{"location":"usage/networking/loadbalancer/#example-network-resource","title":"Example Network Resource","text":"<p>An example of how to define a <code>LoadBalancer</code> resource in <code>Ironcore</code> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: LoadBalancer\nmetadata:\n  namespace: default\n  name: loadbalancer-sample\nspec:\n  type: Public\n  ipFamilies: [IPv4]\n  networkRef:\n    name: network-sample\n  networkInterfaceSelector:\n    matchLabels:\n      app: web\n  ports:\n  - port: 80\n</code></pre> (<code>Note</code>: Refer to E2E Examples for more detailed examples.)</p>"},{"location":"usage/networking/loadbalancer/#key-fields","title":"Key Fields:","text":"<ul> <li><code>type</code>(<code>string</code>): The type of <code>LoadBalancer</code>. Currently two types of <code>Loadbalancer</code> are supported: <ul> <li><code>Public</code>: LoadBalancer that allocates public IP and routes a stable public IP.</li> <li><code>Internal</code>: LoadBalancer that allocates and routes network-internal, stable IPs.</li> </ul> </li> <li><code>ipFamilies</code>(<code>list</code>): ipFamilies are the IP families the LoadBalancer should have(Supported values are <code>IPv4</code> and <code>IPv6</code>). </li> <li><code>ips</code>(<code>list</code>): The ips are the list of IPs to use. This can only be used when the type is LoadBalancerTypeInternal.</li> <li><code>networkRef</code>(<code>string</code>): networkRef is the Network this LoadBalancer should belong to.</li> <li><code>networkInterfaceSelector</code>(<code>labelSelector</code>): networkInterfaceSelector defines the NetworkInterfaces for which this LoadBalancer should be applied</li> <li><code>ports</code>(<code>list</code>): ports are the list of LoadBalancer ports should allow<ul> <li><code>protocol</code>(<code>string</code>): protocol is the protocol the load balancer should allow. Supported protocols are <code>UDP</code>, <code>TCP</code>, and <code>SCTP</code>, if not specified defaults to TCP.</li> <li><code>port</code>(<code>int</code>): port is the port to allow.</li> <li><code>endPort</code>(<code>int</code>): endPort marks the end of the port range to allow. If unspecified, only a single port <code>port</code> will be allowed.</li> </ul> </li> </ul>"},{"location":"usage/networking/loadbalancer/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li> <p>NetworkInterfaces selection: LoadBalancerController continuously watches for <code>LoadBalancer</code> resources and reconciles. LoadBalancer resource dynamically selects multiple target <code>NetworkInterfaces</code> via a <code>networkInterfaceSelector</code> LabelSelector from the spec. Once the referenced Network is in <code>Available</code> state, the Loadbalancer destination IP list and referencing <code>NetworkInterface</code> is prepared by iterating over selected NetworkIntrefaces status information.</p> </li> <li> <p>Preparing Routing State Object: Once the destination list is available <code>LoadBalancerRouting</code> resource is created. <code>LoadBalancerRouting</code> describes <code>NetworkInterfaces</code> load balanced traffic is routed to. This object describes the state of the LoadBalancer and results of the LoadBalancer definition specifically <code>networkInterfaceSelector</code> and <code>networkRef</code>.  Later this information is used at the Ironcore API level to describe the explicit targets in a pool traffic is routed to.</p> </li> </ul> <p>Sample <code>LoadBalancerRouting</code> object(<code>Note</code>: it is created by LoadBalancerController) <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: LoadBalancerRouting\nmetadata:\n  namespace: default\n  name: loadbalancer-sample # Same name as the load balancer it originates from.\n# networkRef references the exact network object the routing belongs to.\nnetworkRef:\n  name: network-sample\n# destinations list the target network interface instances (including UID) for load balancing.\ndestinations:\n  - name: my-machine-interface-1\n    uid: 2020dcf9-e030-427e-b0fc-4fec2016e73a\n  - name: my-machine-interface-2\n    uid: 2020dcf9-e030-427e-b0fc-4fec2016e73d\n</code></pre> LoadBalancer status update: The <code>LoadBalancerController</code> in ironcore-net takes care of allocating IPs for defined <code>ipFamilies</code> in the spec and updates them in its <code>status.ips</code>.</p>"},{"location":"usage/networking/natgateway/","title":"NATGateway","text":"<p>In the <code>Ironcore</code> project, a <code>NATGateway</code> (Network Address Translation Gateway) facilitates outbound internet connectivity in private subnets, ensuring that instances in private subnets can access external services without exposing them to unauthorized inbound traffic.</p> <p>It is a critical network service that provides secure and controlled internet access for private resources in the <code>Ironcore</code> infrastructure. It is enforced by the underlying <code>Ironcore's</code> network plugin called  ironcore-net </p>"},{"location":"usage/networking/natgateway/#example-natgateway-resource","title":"Example NATGateway Resource","text":"<p>An example of how to define a <code>NATGateway</code> resource in <code>Ironcore</code></p> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: NATGateway\nmetadata:\n  namespace: default\n  name: natgateway-sample\nspec:\n  type: Public\n  ipFamily: IPv4\n  portsPerNetworkInterface: 64\n  networkRef:\n    name: network-sample\n</code></pre>"},{"location":"usage/networking/natgateway/#key-fields","title":"Key Fields","text":"<ul> <li> <p><code>type</code>(<code>string</code>): This represents a NATGateway type that allocates and routes a stable public IP. The supported value for type is <code>public</code></p> </li> <li> <p><code>ipFamily</code>(<code>string</code>): <code>IPFamily</code> is the IP family of the <code>NATGateway</code>. Supported values for IPFamily are <code>IPv4</code> and <code>IPv6</code>.</p> </li> <li> <p><code>portsPerNetworkInterface</code>(<code>int32</code>): This Specifies the number of ports allocated per network interface and controls how many simultaneous connections can be handled per interface. </p> <p>If empty, 2048 (DefaultPortsPerNetworkInterface) is the default.</p> </li> <li> <p><code>networkRef</code>(<code>string</code>): It represents which network this <code>NATGateway</code> serves.</p> </li> </ul>"},{"location":"usage/networking/natgateway/#example-use-case","title":"Example Use Case:","text":"<p>Imagine you have a private server in a private subnet without a public IP. It needs to download software updates from the internet. Instead of giving it direct internet access (which compromises security), the server sends its requests through the NAT Gateway. The NAT Gateway fetches the updates and returns them to the server while keeping the server's private IP hidden from the external world.</p>"},{"location":"usage/networking/natgateway/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li> <p>Fetch NATGateway Resource: It fetches the current state of <code>NATGateways</code>, Based on user specifications the desired state of <code>NATGateway</code> is determined. This includes the number of NAT Gateways, their types, associated subnets, and routing configurations.</p> </li> <li> <p>Compare and Reconcile: The reconciler keeps monitoring the state of NAT Gateways to detect any changes or drifts from the desired state, triggering the reconciliation process as needed.</p> <ul> <li> <p>Creation: If a NAT Gateway specified in the desired state does not exist in the current state, it is created. For instance, creating a public NAT Gateway in a public subnet to provide internet access to instances in private subnets.</p> </li> <li> <p>Update: If a NAT Gateway exists but its configuration differs from the desired state, it is updated accordingly. This may involve modifying routing tables or changing associated Elastic IPs.</p> </li> <li> <p>Deletion: If a NAT Gateway exists in the current state but is not present in the desired state, it is deleted to prevent unnecessary resource utilization.</p> </li> </ul> </li> <li> <p>Error Handling and Logging: Throughout the reconciliation process, any errors encountered are logged, schedule retries as necessary to ensure eventual consistency.</p> </li> <li> <p>Update Status: After reconciling all <code>NATGateways</code>, log the successful reconciliation and update the <code>NATGateways</code> status with the corresponding values for <code>ips</code>as shown below.</p> </li> </ul> <pre><code>status:\n  ips:\n  - name: ip1\n    ip: 10.0.0.1\n</code></pre>"},{"location":"usage/networking/network/","title":"Network","text":"<p>A <code>Network</code> resource in <code>Ironcore</code> refers to a logically isolated network.  This further allows you to fully control your networking environment, including resource placement, connectivity, peering and security.  The <code>NetworkController</code> reconciler leverages this information to create a Network in Ironcore infrastructure. <code>Machine</code> type is provided with provision to integrate with the Network via <code>NetworkInterface</code>.</p>"},{"location":"usage/networking/network/#example-network-resource","title":"Example Network Resource","text":"<p>An example of how to define a <code>Network</code> resource in <code>Ironcore</code> <pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: Network\nmetadata:\n  name: network-sample\nspec:\n  peerings:\n  - name: peering1\n    networkRef:\n      name: network-sample2\n</code></pre></p>"},{"location":"usage/networking/network/#key-fields","title":"Key Fields:","text":"<ul> <li><code>providerID</code>(<code>string</code>): providerID is the provider-internal ID of the network.</li> <li><code>peerings</code>(<code>list</code>): peerings are the list of network peerings with this network(Optional).</li> <li><code>incomingPeerings</code>(<code>list</code>): incomingPeerings is a list of PeeringClaimRefs which is nothing but peering claim references of other networks.</li> </ul>"},{"location":"usage/networking/network/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li>Network creation: <code>ironcore-net</code> which is the network provider for Ironcore realizes the <code>Network</code> resource via <code>apinetlet</code> controllers. When an Ironcore <code>Network</code> is created, a corresponding <code>core.apinet.ironcore.dev/Network</code> is created in the apinet cluster. The name of the Network in the apinet cluster is the uid of the Network in the Ironcore cluster.</li> </ul> <p>Once created and with an allocated ID, the Ironcore Network will be patched with the corresponding provider ID of the apinet Network and set to state: Available. The provider ID format &amp; parsing can be found in provider.go.   Once resource is in available state status is marked to <code>Available</code>. The format of a network provider ID is as follows:   <code>ironcore-net://&lt;namespace&gt;/&lt;name&gt;/&lt;id&gt;/&lt;uid&gt;</code></p> <ul> <li>Network peering process: Network peering is a technique used to interleave two isolated networks, allowing members of both networks to communicate with each  other as if they were in the same networking domain,  <code>NetworkPeeringController</code> facilitates this process.</li> <li>Information related to the referenced <code>Network</code> to be paired with is retrieved from the <code>peering</code> part of the spec.</li> <li>Validation is done to see if both Networks have specified a matching peering item (i.e. reference each other via <code>networkRef</code>) to mutually accept the peering.</li> <li> <p>The (binding) phase of a <code>spec.peerings</code> item is reflected in a corresponding <code>status.peerings</code> item with the same name.      The phase can either be <code>Pending</code>, meaning there is no active peering or <code>Bound</code> meaning the peering as described in the <code>spec.peerings</code> item is in place. </p> </li> <li> <p>Network Release Controller: <code>NetworkReleaseController</code> continuously checks if claiming Networks in other Network's peerings section still exist if not present it will be removed from the <code>incomingPeerings</code> list.</p> </li> </ul>"},{"location":"usage/networking/networkinterface/","title":"NetworkInterface","text":"<p>A <code>NetworkInterface</code> resource in <code>Ironcore</code> represents a connection point between a virtual machine(VM) and a virtual network. It encapsulates the configuration and life cycle management of the virtual network interface, ensuring seamless connectivity for VMs.</p> <p>The <code>MachineEphemeralNetworkInterfaceReconciler</code> is responsible for managing the lifecycle of ephemeral network interfaces associated with machines. Its primary function is to ensure that the actual state of these network interfaces aligns with the desired state specified in each machine's configuration.</p>"},{"location":"usage/networking/networkinterface/#example-networkpolicy-resource","title":"Example NetworkPolicy Resource","text":"<p>An example of how to define a <code>NetworkInterface</code> resource in <code>Ironcore</code></p> <p><pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: NetworkInterface\nmetadata:\n  name: networkinterface-sample\nspec:\n  networkRef:\n    name: network-sample\n  ipFamilies:\n    - IPv4\n  ips:\n    - value: 10.0.0.1 # internal IP\n  virtualIP:\n    virtualIPRef:\n      name: virtualip-sample\n</code></pre> Note: For a detailed end-to-end example to understand the ephemeral and non-ephemeral <code>NetworkInterface</code> resource, please refer E2E Examples</p>"},{"location":"usage/networking/networkinterface/#key-fields","title":"Key Fields","text":"<ul> <li> <p><code>networkRef</code>(<code>string</code>): <code>NetworkRef</code> is the Network this NetworkInterface is connected to</p> </li> <li> <p><code>ipFamilies</code>(<code>list</code>): <code>IPFamilies</code> defines the list of IPFamilies this <code>NetworkInterface</code> supports. Supported values for IPFamily are <code>IPv4</code> and <code>IPv6</code>.</p> </li> <li> <p><code>ips</code>(<code>list</code>): <code>IPs</code> are the list of provided internal IPs which should be assigned to this NetworkInterface</p> </li> <li> <p><code>virtualIP</code>: <code>VirtualIP</code> specifies the public ip that should be assigned to this NetworkInterface.</p> </li> </ul>"},{"location":"usage/networking/networkinterface/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li> <p>Fetch Machine Resource: Retrieve the specified Machine resource from the reconciliation request. If the Machine is marked for deletion (indicated by a non-zero DeletionTimestamp), exit the process without further action.</p> </li> <li> <p>Generate Desired Ephemeral Network Interfaces: Analyze the Machine's specification to identify the desired ephemeral NetworkInterface resources. Construct a map detailing these desired NetworkInterfaces, including their configurations and expected states.</p> </li> <li> <p>Fetch Existing NetworkInterfaces: List all existing NetworkInterface resources within the same namespace as the Machine.</p> </li> <li> <p>Compare and Reconcile:</p> <ul> <li>For each existing Network Interface: Determine if it is managed by the current Machine and whether it matches the desired state.</li> <li>If unmanaged but should be managed, avoid adopting it to prevent conflicts.</li> <li>For each desired Network Interface not present: Create the missing <code>NetworkInterface</code> and establish the Machine as its controller.</li> </ul> </li> <li> <p>Handle Errors: Collect any errors encountered during the reconciliation of individual NetworkInterfaces. Log these errors and schedule retries as necessary to ensure eventual consistency.</p> </li> <li> <p>Update Status: After reconciling all NetworkInterfaces, log the successful reconciliation and update the <code>NetworkInterface</code> status with the corresponding values for <code>ips</code>, <code>state</code>, and <code>virtualIP</code>, as shown below.</p> </li> </ul> <p><pre><code>status:\n  ips:\n  - 10.0.0.1\n  lastStateTransitionTime: \"2025-01-13T11:39:17Z\"\n  state: Available\n  virtualIP: 172.89.244.23\n</code></pre> The <code>state</code> is updated as one of the following lifecycle states based on the reconciliation result - Pending - Available - Error</p>"},{"location":"usage/networking/networkpolicy/","title":"NetworkPolicy","text":"<p>In <code>Ironcore</code>, NetworkPolicies are implemented based on the standard Kubernetes <code>NetworkPolicy</code> approach, which is enforced by the underlying <code>Ironcore's</code> network plugin  ironcore-net  and other components. These policies use label selectors to define the source and destination of allowed traffic within the same network and can specify rules for both ingress (incoming) and egress (outgoing) traffic. </p> <p>In the <code>Ironcore</code> ecosystem, the <code>NetworkPolicy</code> has the following characteristics:</p> <ul> <li> <p>NetworkPolicy is applied exclusively to NetworkInterfaces selected using label selectors.</p> </li> <li> <p>These NetworkInterfaces must belong to the same network.</p> </li> <li> <p>The policy governs traffic to and from other <code>NetworkInterfaces</code>, <code>LoadBalancers</code>, etc., based on the rules defined in the NetworkPolicy.</p> </li> </ul>"},{"location":"usage/networking/networkpolicy/#example-networkpolicy-resource","title":"Example NetworkPolicy Resource","text":"<p>An example of how to define a <code>NetworkPolicy</code> resource in <code>Ironcore</code></p> <p><pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: NetworkPolicy\nmetadata:\n  namespace: default\n  name: my-network-policy\nspec:\n  networkRef:\n    name: my-network\n  networkInterfaceSelector:\n    matchLabels:\n      app: db\n  policyTypes:\n  - Ingress\n  - Egress\n  ingress:\n  - from:\n    - ipBlock:\n        cidr: 172.17.0.0/16\n    - objectSelector:\n        kind: NetworkInterface\n        matchLabels:\n          app: web\n    - objectSelector:\n        kind: LoadBalancer\n        matchLabels:\n          app: web\n    # Ports always have to be specified. Only traffic matching the ports\n    # will be allowed.\n    ports:\n    - protocol: TCP\n      port: 5432\n  egress:\n  - to:\n    - ipBlock:\n        cidr: 10.0.0.0/24\n    ports:\n    - protocol: TCP\n      port: 8080\n</code></pre> https://github.com/ironcore-dev/ironcore/tree/main/config/samples/e2e/network-policy</p> <p>(<code>Note</code>: Refer to E2E Examples for more detailed example on networkpolicy to understant e2e flow)</p>"},{"location":"usage/networking/networkpolicy/#key-fields","title":"Key Fields","text":"<ul> <li> <p><code>networkRef</code>(<code>string</code>): NetworkRef is the Network to regulate using this NetworkPolicy.</p> </li> <li> <p><code>networkInterfaceSelector</code>(<code>labelSelector</code>): NetworkInterfaceSelector defines the target <code>NetworkInterfaces</code> for which this <code>NetworkPolicy</code> should be applied.</p> </li> <li> <p><code>policyTypes</code>(<code>list</code>): There are two supported policyTypes <code>Ingress</code> and <code>Egress</code>.</p> </li> <li> <p><code>ingress</code>(<code>list</code>): An Ingress section in a <code>NetworkPolicy</code> defines a list of <code>NetworkPolicyIngressRules</code> that specify which incoming traffic is allowed. Each <code>NetworkPolicy</code> can have multiple ingress rules, and each rule allows traffic that satisfies both the from and ports criteria.</p> </li> </ul> <p>For example, a <code>NetworkPolicy</code> with a single ingress rule may permit traffic on a specific port and only from one of the following sources:   - An IP range, defined using an ipBlock.   - A set of resources identified by an objectSelector.</p> <ul> <li><code>egress</code>(<code>list</code>): egress defines the list of <code>NetworkPolicyEgressRules</code>. Each NetworkPolicy may include a list of allowed egress rules. Each rule allows traffic that matches both <code>to</code> and <code>ports</code> sections. The example policy contains a single rule, which matches traffic on a single port to any destination in 10.0.0.0/24.</li> </ul>"},{"location":"usage/networking/networkpolicy/#reconciliation-process","title":"Reconciliation Process:","text":"<p>The <code>NetworkPolicyReconciler</code> in the Ironcore project is responsible for managing the lifecycle of <code>NetworkPolicy</code> resources. Its primary function is to ensure that the rules specified by the user in the NetworkPolicy resource are enforced and applied on the target <code>NetworkInterface</code>.</p> <p>The  apinetlet  component in <code>ironcore-net</code> plugin is responsible for translating the policy rules into another APInet type resource <code>NetworkPolicyRule</code>. Finally, the  metalnetlet  component in <code>ironcore-net</code> and other components propagates these rules for enforcement at <code>dpservice</code> level in the Ironcore infrastucture.</p> <p>The reconciliation process involves several key steps:</p> <ul> <li> <p>Fetching the NetworkPolicy Resource: The reconciler retrieves the NetworkPolicy resource specified in the reconciliation request. If the resource is not found, it may have been deleted, and the reconciler will handle this scenario appropriately.</p> </li> <li> <p>Validating the NetworkPolicy: The retrieved NetworkPolicy is validated to ensure it confirms the expected specifications. This includes checking fields such as NetworkRef, NetworkInterfaceSelector, Ingress, Egress, and PolicyTypes to ensure they are correctly defined.</p> </li> <li> <p>Fetching Associated Network Interfaces: Using the NetworkInterfaceSelector, the reconciler identifies the network interfaces that are subject to the policy.</p> </li> <li> <p>Applying Policy Rules: The reconciler translates the ingress and egress rules defined in the NetworkPolicy into configurations that can be enforced by the underlying network infrastructure. This involves interacting with other components responsible for NetworkPolicy or Firewall rule enforcement.</p> </li> <li> <p>Handling Errors and Reconciliation Loops: If errors occur during any of the above steps, the reconciler will log the issues and may retry the reconciliation. </p> </li> </ul>"},{"location":"usage/networking/virtualip/","title":"VirtualIP","text":"<p>A <code>Virtual IP (VIP)</code> in  the <code>Ironcore</code> ecosystem is an abstract network resource representing an IP address that is dynamically associated with an <code>ironcore</code> <code>networkInterface</code>, which in turn is linked to an <code>ironcore machine/vm</code>.</p>"},{"location":"usage/networking/virtualip/#examaple-virtualip-resource","title":"Examaple VirtualIP Resource","text":"<pre><code>apiVersion: networking.ironcore.dev/v1alpha1\nkind: VirtualIP\nmetadata:\n  name: virtualip-sample\nspec:\n  type: Public\n  ipFamily: IPv4\n</code></pre>"},{"location":"usage/networking/virtualip/#key-fields","title":"Key Fields","text":"<ul> <li> <p><code>type</code>(<code>string</code>):  Currently supported type is <code>public</code>, which allocates and routes a stable public IP.</p> </li> <li> <p><code>ipFamily</code>(<code>string</code>): <code>IPFamily</code> is the ip family of the VirtualIP. Supported values for IPFamily are <code>IPv4</code> and <code>IPv6</code>.</p> </li> </ul>"},{"location":"usage/networking/virtualip/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li> <p>VirtualIP Creation:  A VirtualIP resource is created, specifying attributes like <code>ipFamily</code>: IPv4 or IPv6 and <code>Type</code>: public </p> </li> <li> <p>Reconciliation and IP Assignment:  The VirtualIP reconciler Creates or updates a corresponding APINet IP in Ironcore's APINet system. Ensures the IP is dynamically allocated and made available for use.</p> </li> <li> <p>Error Handling: If the creation or update of the APINet IP fails, update the VirtualIP status to indicate it is unallocated. Requeue the reconciliation to retry the operation.</p> </li> <li> <p>Synchronize Status: Update the VirtualIP status to reflect the actual state of the APINet IP. If successfully allocated, update the status with the assigned IP address.</p> </li> </ul> <p>for example:   <pre><code>status:\n  ip: 10.0.0.1 # This will be populated by the corresponding controller.\n</code></pre> - Networking Configuration:      - VM Integration: The allocated VirtualIP is associated with the VM through network configuration mechanisms     - Load Balancer Integration: If a load balancer is used, the virtualIP is configured as the frontend IP to route requests to the VM.</p>"},{"location":"usage/storage/bucket/","title":"Bucket","text":"<p>A <code>Bucket</code> in <code>Ironcore</code> refers to a storage resource that organizes and manages data, similar to the concept of buckets in cloud storage services like Amazon S3. Buckets are containers for storing objects, such as files or data blobs, and are crucial for managing storage workloads.</p>"},{"location":"usage/storage/bucket/#example-bucket-resource","title":"Example Bucket Resource","text":"<p>An example of how to define a <code>Bucket</code> resource in <code>Ironcore</code></p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: Bucket\nmetadata:\n  name: bucket-sample\nspec:\n  bucketClassRef:\n    name: bucketclass-sample\n#  bucketPoolRef:\n#    name: bucketpool-sample\n</code></pre>"},{"location":"usage/storage/bucket/#key-fields","title":"Key Fields:","text":"<ul> <li><code>bucketClassRef</code>(<code>string</code>): </li> <li>Mandatory field</li> <li> <p><code>BucketClassRef</code> is the BucketClass of a bucket</p> </li> <li> <p><code>bucketPoolRef</code>(<code>string</code>):</p> </li> <li>Optional field</li> <li><code>bucketPoolRef</code> indicates which BucketPool to use for the bucket, if not specified the controller itself picks the available bucketPool</li> </ul>"},{"location":"usage/storage/bucket/#usage","title":"Usage","text":"<ul> <li> <p>Data Storage: Use <code>Buckets</code> to store and organize data blobs, files, or any object-based data.</p> </li> <li> <p>Multi-Tenant Workloads: Leverage buckets for isolated and secure data storage in multi-tenant environments by using separate BucketClass or BucketPool references.</p> </li> <li> <p>Secure Access: Buckets store a reference to the <code>Secret</code> securely in their status, and the <code>Secret</code> has the access credentials, which applications can retrieve access details from the <code>Secret</code>.</p> </li> </ul>"},{"location":"usage/storage/bucket/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li> <p>The controller detects changes and fetches bucket details.</p> </li> <li> <p>Creation/Update ensures the backend bucket exists, metadata is synced, and credentials are updated.</p> </li> <li> <p>The bucket will automatically sync with the backend storage system, and update the Bucket's state (e.g., <code>Available</code>, <code>Pending</code>, or <code>Error</code>) in the bucket's status.</p> </li> <li> <p>Access details and credentials will be managed securely using Kubernetes <code>Secret</code> and the bucket status will track a reference to the <code>Secret</code>.</p> </li> <li> <p>During deletion, resources will be cleaned up gracefully without manual intervention.</p> </li> <li> <p>If the bucket is not ready (e.g., backend issues), reconciliation will retry</p> </li> </ul>"},{"location":"usage/storage/bucketclass/","title":"BucketClass","text":"<p>A <code>BucketClass</code> is a concept used to define and manage different types of storage buckets, typically based on resource capabilities. It is conceptually similar to Kubernetes <code>StorageClass</code>, enabling users to specify the desired properties for an Ironcore <code>Bucket</code> resource creation.</p>"},{"location":"usage/storage/bucketclass/#example-bucketclass-resource","title":"Example BucketClass Resource","text":"<p>An example of how to define a <code>BucketClass</code> resource in <code>Ironcore</code></p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: BucketClass\nmetadata:\n  name: bucketclass-sample\ncapabilities:\n  tps: 100Mi\n  iops: 100\n</code></pre>"},{"location":"usage/storage/bucketclass/#key-fields","title":"Key Fields:","text":"<ul> <li><code>capabilities</code>: Capabilities has <code>tps</code> and <code>iops</code> fields which need to be specified, it's a mandatory field,</li> <li> <p><code>tps</code>(<code>string</code>): The <code>tps</code> represents transactions per second.</p> </li> <li> <p><code>iops</code>(<code>string</code>):  <code>iops</code> is the number of input/output operations a storage device can complete per second.</p> </li> </ul>"},{"location":"usage/storage/bucketclass/#usage","title":"Usage","text":"<ul> <li> <p>BucketClass Definition: Create a <code>BucketClass</code> to set storage properties based on resource capabilities.</p> </li> <li> <p>Associate with buckets: Link a <code>BucketClass</code> to a <code>Bucket</code> using a reference in the Bucket resource.</p> </li> <li> <p>Dynamic configuration: Update the <code>BucketClass</code> to modify storage properties for all its Buckets.</p> </li> </ul>"},{"location":"usage/storage/bucketclass/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li> <p>Fetches &amp; Validates: Retrieves the <code>BucketClass</code> from the cluster and checks if it exists.</p> </li> <li> <p>Synchronizes State: Keeps the <code>BucketClass</code> resource updated with its current state and dependencies.</p> </li> <li> <p>Monitors Dependencies: Watches for changes in dependent Bucket resources and reacts accordingly.</p> </li> <li> <p>Handles Errors: Requeues the reconciliation to handle errors and ensure successful completion.</p> </li> <li> <p>Handles Deletion: Cleans up references, removes the finalizer, and ensures no dependent Buckets exist before deletion.</p> </li> </ul>"},{"location":"usage/storage/bucketpool/","title":"BucketPool","text":"<p>A <code>BucketPool</code> is a resource in <code>Ironcore</code> that represents a pool of storage buckets managed collectively. It defines the infrastructure's storage configuration used to provision and manage buckets, ensuring resource availability and compatibility with associated BucketClasses.</p>"},{"location":"usage/storage/bucketpool/#example-bucketpool-resource","title":"Example BucketPool Resource","text":"<p>An example of how to define a <code>BucketPool</code> resource in <code>Ironcore</code></p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: BucketPool\nmetadata:\n  name: bucketpool-sample\nspec:\n  providerID: ironcore://shared\n#status:\n#  state: Available\n#  availableBucketClasses:\n#    ironcore.dev/fast-class: 10Gi\n#    ironcore.dev/slow-class: 100Gi\n</code></pre>"},{"location":"usage/storage/bucketpool/#key-fields","title":"Key Fields:","text":"<ul> <li> <p><code>ProviderID</code>(<code>string</code>):  The <code>providerId</code> helps the controller identify and communicate with the correct storage system within the specific backened storage porvider.</p> <p>for example <code>ironcore://shared</code></p> </li> </ul>"},{"location":"usage/storage/bucketpool/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li> <p>Bucket Type Discovery: It constantly checks what kinds of buckets (BucketClasses) are available in the <code>Ironcore</code> Infrastructure.</p> </li> <li> <p>Compatibility Check: Evaluating whether the BucketPool can create and manage each bucket type based on its capabilities.</p> </li> <li> <p>Status Update: Updating the BucketPool's status to indicate the bucket types it supports, like a menu of available options.</p> </li> <li> <p>Event Handling: Watches for changes in BucketClass resources and ensures the associated BucketPool is reconciled when relevant changes occur.</p> </li> </ul>"},{"location":"usage/storage/volume/","title":"Volume","text":"<p>The <code>Ironcore</code> <code>Volume</code> is a storage abstraction provided by the <code>Ironcore Runtime Interface</code> <code>(IRI)</code> service, designed to integrate with external storage backend for managing persistent storage. It acts as a managed storage unit, ensuring consistency, scalability, and compatibility with Kubernetes workloads. By integrating Ironcore Volumes with Kubernetes, users benefit from seamless storage management, automation, and advanced features such as encryption and scalability, making it suitable for modern cloud-native and hybrid applications.</p>"},{"location":"usage/storage/volume/#example-volume-resource","title":"Example Volume Resource","text":"<p>An example of how to define a <code>Volume</code> resource in <code>Ironcore</code></p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: Volume\nmetadata:\n  name: volume-sample\nspec:\n  volumeClassRef:\n    name: volumeclass-sample\n  # volumePoolRef:\n  #   name: volumepool-sample\n  resources:\n    storage: 100Gi\n</code></pre>"},{"location":"usage/storage/volume/#key-fields","title":"Key Fields:","text":"<ul> <li> <p><code>volumeClassRef</code>(<code>string</code>): <code>volumeClassRef</code> refers to the name of an Ironcore <code>volumeClass</code>( for eg: <code>slow</code>, <code>fast</code>, <code>super-fast</code> etc.) to create a volume,</p> </li> <li> <p><code>volumePoolRef</code> (<code>string</code>):   <code>VolumePoolRef</code> indicates which VolumePool to use for a volume. If unset, the scheduler will figure out a suitable <code>VolumePoolRef</code>.</p> </li> <li> <p><code>resources</code>: <code>Resources</code> is a description of the volume's resources and capacity.</p> </li> </ul>"},{"location":"usage/storage/volume/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li> <p>Fetch Volume Resource: Retrieve the <code>Volume</code> resource and clean up any orphaned <code>IRI</code> volumes if the resource is missing.</p> </li> <li> <p>Add Finalizer: Ensure a finalizer is added to manage cleanup during deletion.</p> </li> <li> <p>Check IRI Volumes: List and identify <code>IRI</code> volumes linked to the <code>Volume</code> resource.</p> </li> <li> <p>Create or Update Volume:</p> </li> <li>Create a new IRI volume if none exists.</li> <li> <p>Update existing IRI volumes if attributes like size or encryption need adjustments.</p> </li> <li> <p>Sync Status: Reflect the IRI volume's state (e.g., Pending, Available) in the Kubernetes Volume resource's status.</p> </li> <li> <p>Handle Deletion: Safely delete all associated IRI volumes and remove the finalizer to complete the resource lifecycle.</p> </li> </ul>"},{"location":"usage/storage/volumeclass/","title":"VolumeClass","text":"<p>The <code>VolumeClass</code> in <code>Ironcore</code> is a Kubernetes-like abstraction that defines a set of parameters or configurations for provisioning storage resources through the <code>Ironcore Runtime Interface (IRI)</code>. It is conceptually similar to Kubernetes <code>StorageClass</code>, enabling users to specify the desired properties for an Ironcore <code>Volume</code> resource creation.</p>"},{"location":"usage/storage/volumeclass/#example-volumeclass-resource","title":"Example VolumeClass Resource","text":"<p>An example of how to define a <code>VolumeClass</code> resource in <code>Ironcore</code></p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: VolumeClass\nmetadata:\n  name: volumeclass-sample\ncapabilities:\n  tps: 100Mi\n  iops: 100\n</code></pre>"},{"location":"usage/storage/volumeclass/#key-fields","title":"Key Fields:","text":"<ul> <li><code>capabilities</code>: Capabilities has tps and iops fields that need to be specified, it's a mandatory field,</li> <li> <p><code>tps</code>(<code>string</code>): The <code>tps</code> represents transactions per second.</p> </li> <li> <p><code>iops</code>(<code>string</code>): <code>iops</code> is the number of input/output operations a storage device can complete per second.</p> </li> </ul>"},{"location":"usage/storage/volumeclass/#usage","title":"Usage","text":"<ul> <li> <p>VolumeClass Definition: Create a <code>VolumeClass</code> to set storage properties based on resource capabilities.</p> </li> <li> <p>Associate with Volume: Link a <code>VolumeClass</code> to a <code>Volume</code> using a reference in the Volume resource.</p> </li> <li> <p>Dynamic configuration: Update the <code>VolumeClass</code> to modify storage properties for all its Volumes.</p> </li> </ul>"},{"location":"usage/storage/volumeclass/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li> <p>Fetches &amp; Validates: Retrieves the VolumeClass from the cluster and checks if it exists.</p> </li> <li> <p>Synchronizes State: Keeps the VolumeClass resource updated with its current state and dependencies.</p> </li> <li> <p>Monitors Dependencies: Watches for changes in dependent Volume resources and reacts accordingly.</p> </li> <li> <p>Handles Errors: Requeues the reconciliation to handle errors and ensure successful completion.</p> </li> <li> <p>Handles Deletion: Cleans up references, removes the finalizer, and ensures no dependent Volumes exist before deletion.</p> </li> </ul>"},{"location":"usage/storage/volumepool/","title":"VolumePool","text":"<p>A <code>VolumePool</code> is a resource in <code>Ironcore</code> that represents a pool of storage volume managed collectively. It defines the infrastructure's storage configuration used to provision and manage volumes, ensuring resource availability and compatibility with associated <code>VolumeClasses</code>.</p>"},{"location":"usage/storage/volumepool/#example-volumepool-resource","title":"Example VolumePool Resource","text":"<p>An example of how to define a <code>VolumePool</code> resource in <code>Ironcore</code></p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: VolumePool\nmetadata:\n  name: volumepool-sample\nspec:\n  providerID: ironcore://shared\n#status:\n#  state: Available\n#  availableVolumeClasses:\n#    ironcore.dev/fast-class: 10Gi\n#    ironcore.dev/slow-class: 100Gi\n</code></pre>"},{"location":"usage/storage/volumepool/#key-fields","title":"Key Fields:","text":"<ul> <li> <p><code>providerID</code>(<code>string</code>): The <code>providerId</code> helps the controller identify and communicate with the correct storage system within the specific backened storage porvider.</p> <p>for example <code>ironcore://shared</code></p> </li> </ul>"},{"location":"usage/storage/volumepool/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li> <p>Volume Type Discovery: It constantly checks what kinds of volumes (volumeClasses) are available in the <code>Ironcore</code> Infrastructure.</p> </li> <li> <p>Compatibility Check: Evaluating whether the volumePool can create and manage each volume type based on its capabilities.</p> </li> <li> <p>Status Update: Updating the VolumePool's status to indicate the volume types it supports, like a menu of available options.</p> </li> <li> <p>Event Handling: Watches for changes in VolumeClass resources and ensures the associated VolumePool is reconciled when relevant changes occur.</p> </li> </ul>"},{"location":"usage/storage/volumesnapshot/","title":"VolumeSnapshot","text":"<p>The <code>Ironcore</code> <code>VolumeSnapshot</code> resource allows users to take point-in-time snapshots of the content of a <code>Volume</code> without creating an entirely new volume. This functionality allows users to take backup before performing any modifications on data.</p>"},{"location":"usage/storage/volumesnapshot/#example-volumesnapshot-resource","title":"Example VolumeSnapshot Resource","text":"<p>An example of how to define a <code>VolumeSnapshot</code> resource in <code>Ironcore</code></p> <pre><code>apiVersion: storage.ironcore.dev/v1alpha1\nkind: VolumeSnapshot\nmetadata:\n  name: volumesnapshot-sample\nspec:\n  volumeRef:\n    name: volume-sample\n</code></pre>"},{"location":"usage/storage/volumesnapshot/#key-fields","title":"Key Fields:","text":"<ul> <li><code>volumeRef</code>(<code>string</code>): <code>volumeRef</code> refers to the name of an Ironcore <code>volume</code> to create a volume snapshot.</li> </ul>"},{"location":"usage/storage/volumesnapshot/#reconciliation-process","title":"Reconciliation Process:","text":"<ul> <li> <p>Fetch VolumeSnapshot Resource: Retrieve the <code>VolumeSnapshot</code> resource and clean up any orphaned <code>IRI</code> volume snapshots if the resource is missing.</p> </li> <li> <p>Add Finalizer: Ensure a finalizer is added to manage cleanup during deletion.</p> </li> <li> <p>Check IRI VolumeSnapshots: List and identify <code>IRI</code> volume snapshots linked to the <code>VolumeSnapshot</code> resource.</p> </li> <li> <p>Create VolumeSnapshot: Create a new IRI volume snapshot if none exists.</p> </li> <li> <p>Sync Status: Reflect the IRI volume snapshot's state (e.g., Pending, Ready, Failed) in the <code>VolumeSnapshot</code> resource status.</p> </li> <li> <p>Handle Deletion: Safely delete all associated IRI volume snapshots and remove the finalizer to complete the resource lifecycle.</p> </li> </ul>"}]}